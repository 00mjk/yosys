
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9+932 (git sha1 26699340, clang 6.0.0-1ubuntu2 -fPIC -Os)


-- Executing script file `attributes_test.ys' --

1. Executing Verilog-2005 frontend: attributes_test.v
Parsing Verilog input from `attributes_test.v' to AST representation.
Generating RTLIL representation for module `\block_ram'.
Generating RTLIL representation for module `\distributed_ram'.
Generating RTLIL representation for module `\distributed_ram_manual'.
Generating RTLIL representation for module `\distributed_ram_manual_syn'.
Successfully finished Verilog frontend.

2. Executing HIERARCHY pass (managing design hierarchy).

2.1. Analyzing design hierarchy..
Top module:  \block_ram

2.2. Analyzing design hierarchy..
Top module:  \block_ram
Removing unused module `\distributed_ram_manual_syn'.
Removing unused module `\distributed_ram_manual'.
Removing unused module `\distributed_ram'.
Removed 3 unused modules.

3. Executing SYNTH_XILINX pass.

3.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\VCC'.
Generating RTLIL representation for module `\GND'.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\IBUFG'.
Generating RTLIL representation for module `\OBUF'.
Generating RTLIL representation for module `\IOBUF'.
Generating RTLIL representation for module `\OBUFT'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGCTRL'.
Generating RTLIL representation for module `\BUFHCE'.
Generating RTLIL representation for module `\INV'.
Generating RTLIL representation for module `\LUT1'.
Generating RTLIL representation for module `\LUT2'.
Generating RTLIL representation for module `\LUT3'.
Generating RTLIL representation for module `\LUT4'.
Generating RTLIL representation for module `\LUT5'.
Generating RTLIL representation for module `\LUT6'.
Generating RTLIL representation for module `\LUT6_2'.
Generating RTLIL representation for module `\MUXCY'.
Generating RTLIL representation for module `\MUXF7'.
Generating RTLIL representation for module `\MUXF8'.
Generating RTLIL representation for module `\XORCY'.
Generating RTLIL representation for module `\CARRY4'.
Generating RTLIL representation for module `\FDRE'.
Generating RTLIL representation for module `\FDSE'.
Generating RTLIL representation for module `\FDCE'.
Generating RTLIL representation for module `\FDPE'.
Generating RTLIL representation for module `\FDRE_1'.
Generating RTLIL representation for module `\FDSE_1'.
Generating RTLIL representation for module `\FDCE_1'.
Generating RTLIL representation for module `\FDPE_1'.
Generating RTLIL representation for module `\LDCE'.
Generating RTLIL representation for module `\LDPE'.
Generating RTLIL representation for module `\RAM16X1S'.
Generating RTLIL representation for module `\RAM16X1S_1'.
Generating RTLIL representation for module `\RAM32X1S'.
Generating RTLIL representation for module `\RAM32X1S_1'.
Generating RTLIL representation for module `\RAM64X1S'.
Generating RTLIL representation for module `\RAM64X1S_1'.
Generating RTLIL representation for module `\RAM128X1S'.
Generating RTLIL representation for module `\RAM128X1S_1'.
Generating RTLIL representation for module `\RAM256X1S'.
Generating RTLIL representation for module `\RAM512X1S'.
Generating RTLIL representation for module `\RAM16X2S'.
Generating RTLIL representation for module `\RAM32X2S'.
Generating RTLIL representation for module `\RAM64X2S'.
Generating RTLIL representation for module `\RAM16X4S'.
Generating RTLIL representation for module `\RAM32X4S'.
Generating RTLIL representation for module `\RAM16X8S'.
Generating RTLIL representation for module `\RAM32X8S'.
Generating RTLIL representation for module `\RAM16X1D'.
Generating RTLIL representation for module `\RAM16X1D_1'.
Generating RTLIL representation for module `\RAM32X1D'.
Generating RTLIL representation for module `\RAM32X1D_1'.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM64X1D_1'.
Generating RTLIL representation for module `\RAM128X1D'.
Generating RTLIL representation for module `\RAM256X1D'.
Generating RTLIL representation for module `\RAM32M'.
Generating RTLIL representation for module `\RAM32M16'.
Generating RTLIL representation for module `\RAM64M'.
Generating RTLIL representation for module `\RAM64M8'.
Generating RTLIL representation for module `\ROM16X1'.
Generating RTLIL representation for module `\ROM32X1'.
Generating RTLIL representation for module `\ROM64X1'.
Generating RTLIL representation for module `\ROM128X1'.
Generating RTLIL representation for module `\ROM256X1'.
Generating RTLIL representation for module `\SRL16E'.
Generating RTLIL representation for module `\SRLC16E'.
Generating RTLIL representation for module `\SRLC32E'.
Generating RTLIL representation for module `\MULT18X18'.
Generating RTLIL representation for module `\MULT18X18S'.
Generating RTLIL representation for module `\MULT18X18SIO'.
Generating RTLIL representation for module `\DSP48A'.
Generating RTLIL representation for module `\DSP48A1'.
Generating RTLIL representation for module `\DSP48E1'.
Successfully finished Verilog frontend.

3.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v' to AST representation.
Generating RTLIL representation for module `\FDCPE'.
Generating RTLIL representation for module `\FDRSE'.
Generating RTLIL representation for module `\LDCPE'.
Generating RTLIL representation for module `\AND2B1L'.
Generating RTLIL representation for module `\OR2L'.
Generating RTLIL representation for module `\MUXF5'.
Generating RTLIL representation for module `\MUXF6'.
Generating RTLIL representation for module `\MUXF9'.
Generating RTLIL representation for module `\CARRY8'.
Generating RTLIL representation for module `\ORCY'.
Generating RTLIL representation for module `\MULT_AND'.
Generating RTLIL representation for module `\SRL16'.
Generating RTLIL representation for module `\SRLC16'.
Generating RTLIL representation for module `\CFGLUT5'.
Generating RTLIL representation for module `\RAMB16_S1'.
Generating RTLIL representation for module `\RAMB16_S2'.
Generating RTLIL representation for module `\RAMB16_S4'.
Generating RTLIL representation for module `\RAMB16_S9'.
Generating RTLIL representation for module `\RAMB16_S18'.
Generating RTLIL representation for module `\RAMB16_S36'.
Generating RTLIL representation for module `\RAMB16_S1_S1'.
Generating RTLIL representation for module `\RAMB16_S1_S2'.
Generating RTLIL representation for module `\RAMB16_S1_S4'.
Generating RTLIL representation for module `\RAMB16_S1_S9'.
Generating RTLIL representation for module `\RAMB16_S1_S18'.
Generating RTLIL representation for module `\RAMB16_S1_S36'.
Generating RTLIL representation for module `\RAMB16_S2_S2'.
Generating RTLIL representation for module `\RAMB16_S2_S4'.
Generating RTLIL representation for module `\RAMB16_S2_S9'.
Generating RTLIL representation for module `\RAMB16_S2_S18'.
Generating RTLIL representation for module `\RAMB16_S2_S36'.
Generating RTLIL representation for module `\RAMB16_S4_S4'.
Generating RTLIL representation for module `\RAMB16_S4_S9'.
Generating RTLIL representation for module `\RAMB16_S4_S18'.
Generating RTLIL representation for module `\RAMB16_S4_S36'.
Generating RTLIL representation for module `\RAMB16_S9_S9'.
Generating RTLIL representation for module `\RAMB16_S9_S18'.
Generating RTLIL representation for module `\RAMB16_S9_S36'.
Generating RTLIL representation for module `\RAMB16_S18_S18'.
Generating RTLIL representation for module `\RAMB16_S18_S36'.
Generating RTLIL representation for module `\RAMB16_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWER'.
Generating RTLIL representation for module `\RAMB8BWER'.
Generating RTLIL representation for module `\FIFO16'.
Generating RTLIL representation for module `\RAMB16'.
Generating RTLIL representation for module `\RAMB32_S64_ECC'.
Generating RTLIL representation for module `\FIFO18'.
Generating RTLIL representation for module `\FIFO18_36'.
Generating RTLIL representation for module `\FIFO36'.
Generating RTLIL representation for module `\FIFO36_72'.
Generating RTLIL representation for module `\RAMB18'.
Generating RTLIL representation for module `\RAMB36'.
Generating RTLIL representation for module `\RAMB18SDP'.
Generating RTLIL representation for module `\RAMB36SDP'.
Generating RTLIL representation for module `\FIFO18E1'.
Generating RTLIL representation for module `\FIFO36E1'.
Generating RTLIL representation for module `\RAMB18E1'.
Generating RTLIL representation for module `\RAMB36E1'.
Generating RTLIL representation for module `\FIFO18E2'.
Generating RTLIL representation for module `\FIFO36E2'.
Generating RTLIL representation for module `\RAMB18E2'.
Generating RTLIL representation for module `\RAMB36E2'.
Generating RTLIL representation for module `\URAM288'.
Generating RTLIL representation for module `\URAM288_BASE'.
Generating RTLIL representation for module `\DSP48'.
Generating RTLIL representation for module `\DSP48E'.
Generating RTLIL representation for module `\DSP48E2'.
Generating RTLIL representation for module `\IFDDRCPE'.
Generating RTLIL representation for module `\IFDDRRSE'.
Generating RTLIL representation for module `\OFDDRCPE'.
Generating RTLIL representation for module `\OFDDRRSE'.
Generating RTLIL representation for module `\OFDDRTCPE'.
Generating RTLIL representation for module `\OFDDRTRSE'.
Generating RTLIL representation for module `\IDDR2'.
Generating RTLIL representation for module `\ODDR2'.
Generating RTLIL representation for module `\IDDR'.
Generating RTLIL representation for module `\IDDR_2CLK'.
Generating RTLIL representation for module `\ODDR'.
Generating RTLIL representation for module `\IDELAYCTRL'.
Generating RTLIL representation for module `\IDELAY'.
Generating RTLIL representation for module `\ISERDES'.
Generating RTLIL representation for module `\OSERDES'.
Generating RTLIL representation for module `\IODELAY'.
Generating RTLIL representation for module `\ISERDES_NODELAY'.
Generating RTLIL representation for module `\IODELAYE1'.
Generating RTLIL representation for module `\ISERDESE1'.
Generating RTLIL representation for module `\OSERDESE1'.
Generating RTLIL representation for module `\IDELAYE2'.
Generating RTLIL representation for module `\ODELAYE2'.
Generating RTLIL representation for module `\ISERDESE2'.
Generating RTLIL representation for module `\OSERDESE2'.
Generating RTLIL representation for module `\PHASER_IN'.
Generating RTLIL representation for module `\PHASER_IN_PHY'.
Generating RTLIL representation for module `\PHASER_OUT'.
Generating RTLIL representation for module `\PHASER_OUT_PHY'.
Generating RTLIL representation for module `\PHASER_REF'.
Generating RTLIL representation for module `\PHY_CONTROL'.
Generating RTLIL representation for module `\IDDRE1'.
Generating RTLIL representation for module `\ODDRE1'.
Generating RTLIL representation for module `\IDELAYE3'.
Generating RTLIL representation for module `\ODELAYE3'.
Generating RTLIL representation for module `\ISERDESE3'.
Generating RTLIL representation for module `\OSERDESE3'.
Generating RTLIL representation for module `\BITSLICE_CONTROL'.
Generating RTLIL representation for module `\RIU_OR'.
Generating RTLIL representation for module `\RX_BITSLICE'.
Generating RTLIL representation for module `\RXTX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE_TRI'.
Generating RTLIL representation for module `\IODELAY2'.
Generating RTLIL representation for module `\IODRP2'.
Generating RTLIL representation for module `\IODRP2_MCB'.
Generating RTLIL representation for module `\ISERDES2'.
Generating RTLIL representation for module `\OSERDES2'.
Generating RTLIL representation for module `\IBUF_DLY_ADJ'.
Generating RTLIL representation for module `\IBUF_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUF_ANALOG'.
Generating RTLIL representation for module `\IBUFE3'.
Generating RTLIL representation for module `\IBUFDS'.
Generating RTLIL representation for module `\IBUFDS_DLY_ADJ'.
Generating RTLIL representation for module `\IBUFDS_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDSE3'.
Generating RTLIL representation for module `\IBUFDS_DPHY'.
Generating RTLIL representation for module `\IBUFGDS'.
Generating RTLIL representation for module `\IBUFGDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUF_DCIEN'.
Generating RTLIL representation for module `\IOBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFE3'.
Generating RTLIL representation for module `\IOBUFDS'.
Generating RTLIL representation for module `\IOBUFDS_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDSE3'.
Generating RTLIL representation for module `\OBUFDS'.
Generating RTLIL representation for module `\OBUFDS_DPHY'.
Generating RTLIL representation for module `\OBUFTDS'.
Generating RTLIL representation for module `\KEEPER'.
Generating RTLIL representation for module `\PULLDOWN'.
Generating RTLIL representation for module `\PULLUP'.
Generating RTLIL representation for module `\DCIRESET'.
Generating RTLIL representation for module `\HPIO_VREF'.
Generating RTLIL representation for module `\BUFGCE'.
Generating RTLIL representation for module `\BUFGCE_1'.
Generating RTLIL representation for module `\BUFGMUX'.
Generating RTLIL representation for module `\BUFGMUX_1'.
Generating RTLIL representation for module `\BUFGMUX_CTRL'.
Generating RTLIL representation for module `\BUFGMUX_VIRTEX4'.
Generating RTLIL representation for module `\BUFG_GT'.
Generating RTLIL representation for module `\BUFG_GT_SYNC'.
Generating RTLIL representation for module `\BUFG_PS'.
Generating RTLIL representation for module `\BUFGCE_DIV'.
Generating RTLIL representation for module `\BUFH'.
Generating RTLIL representation for module `\BUFIO2'.
Generating RTLIL representation for module `\BUFIO2_2CLK'.
Generating RTLIL representation for module `\BUFIO2FB'.
Generating RTLIL representation for module `\BUFPLL'.
Generating RTLIL representation for module `\BUFPLL_MCB'.
Generating RTLIL representation for module `\BUFIO'.
Generating RTLIL representation for module `\BUFIODQS'.
Generating RTLIL representation for module `\BUFR'.
Generating RTLIL representation for module `\BUFMR'.
Generating RTLIL representation for module `\BUFMRCE'.
Generating RTLIL representation for module `\DCM'.
Generating RTLIL representation for module `\DCM_SP'.
Generating RTLIL representation for module `\DCM_CLKGEN'.
Generating RTLIL representation for module `\DCM_ADV'.
Generating RTLIL representation for module `\DCM_BASE'.
Generating RTLIL representation for module `\DCM_PS'.
Generating RTLIL representation for module `\PMCD'.
Generating RTLIL representation for module `\PLL_ADV'.
Generating RTLIL representation for module `\PLL_BASE'.
Generating RTLIL representation for module `\MMCM_ADV'.
Generating RTLIL representation for module `\MMCM_BASE'.
Generating RTLIL representation for module `\MMCME2_ADV'.
Generating RTLIL representation for module `\MMCME2_BASE'.
Generating RTLIL representation for module `\PLLE2_ADV'.
Generating RTLIL representation for module `\PLLE2_BASE'.
Generating RTLIL representation for module `\MMCME3_ADV'.
Generating RTLIL representation for module `\MMCME3_BASE'.
Generating RTLIL representation for module `\PLLE3_ADV'.
Generating RTLIL representation for module `\PLLE3_BASE'.
Generating RTLIL representation for module `\MMCME4_ADV'.
Generating RTLIL representation for module `\MMCME4_BASE'.
Generating RTLIL representation for module `\PLLE4_ADV'.
Generating RTLIL representation for module `\PLLE4_BASE'.
Generating RTLIL representation for module `\BUFT'.
Generating RTLIL representation for module `\IN_FIFO'.
Generating RTLIL representation for module `\OUT_FIFO'.
Generating RTLIL representation for module `\HARD_SYNC'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3E'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3A'.
Generating RTLIL representation for module `\STARTUP_SPARTAN6'.
Generating RTLIL representation for module `\STARTUP_VIRTEX4'.
Generating RTLIL representation for module `\STARTUP_VIRTEX5'.
Generating RTLIL representation for module `\STARTUP_VIRTEX6'.
Generating RTLIL representation for module `\STARTUPE2'.
Generating RTLIL representation for module `\STARTUPE3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3A'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX4'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX5'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX6'.
Generating RTLIL representation for module `\CAPTUREE2'.
Generating RTLIL representation for module `\ICAP_SPARTAN3A'.
Generating RTLIL representation for module `\ICAP_SPARTAN6'.
Generating RTLIL representation for module `\ICAP_VIRTEX4'.
Generating RTLIL representation for module `\ICAP_VIRTEX5'.
Generating RTLIL representation for module `\ICAP_VIRTEX6'.
Generating RTLIL representation for module `\ICAPE2'.
Generating RTLIL representation for module `\ICAPE3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3A'.
Generating RTLIL representation for module `\BSCAN_SPARTAN6'.
Generating RTLIL representation for module `\BSCAN_VIRTEX4'.
Generating RTLIL representation for module `\BSCAN_VIRTEX5'.
Generating RTLIL representation for module `\BSCAN_VIRTEX6'.
Generating RTLIL representation for module `\BSCANE2'.
Generating RTLIL representation for module `\DNA_PORT'.
Generating RTLIL representation for module `\DNA_PORTE2'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX4'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX5'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX6'.
Generating RTLIL representation for module `\FRAME_ECCE2'.
Generating RTLIL representation for module `\FRAME_ECCE3'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX4'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX5'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX6'.
Generating RTLIL representation for module `\USR_ACCESSE2'.
Generating RTLIL representation for module `\POST_CRC_INTERNAL'.
Generating RTLIL representation for module `\SUSPEND_SYNC'.
Generating RTLIL representation for module `\KEY_CLEAR'.
Generating RTLIL representation for module `\MASTER_JTAG'.
Generating RTLIL representation for module `\SPI_ACCESS'.
Generating RTLIL representation for module `\EFUSE_USR'.
Generating RTLIL representation for module `\SYSMON'.
Generating RTLIL representation for module `\XADC'.
Generating RTLIL representation for module `\SYSMONE1'.
Generating RTLIL representation for module `\SYSMONE4'.
Generating RTLIL representation for module `\GTPA1_DUAL'.
Generating RTLIL representation for module `\GT11_CUSTOM'.
Generating RTLIL representation for module `\GT11_DUAL'.
Generating RTLIL representation for module `\GT11CLK'.
Generating RTLIL representation for module `\GT11CLK_MGT'.
Generating RTLIL representation for module `\GTP_DUAL'.
Generating RTLIL representation for module `\GTX_DUAL'.
Generating RTLIL representation for module `\CRC32'.
Generating RTLIL representation for module `\CRC64'.
Generating RTLIL representation for module `\GTHE1_QUAD'.
Generating RTLIL representation for module `\GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTHE1'.
Generating RTLIL representation for module `\GTHE2_CHANNEL'.
Generating RTLIL representation for module `\GTHE2_COMMON'.
Generating RTLIL representation for module `\GTPE2_CHANNEL'.
Generating RTLIL representation for module `\GTPE2_COMMON'.
Generating RTLIL representation for module `\GTXE2_CHANNEL'.
Generating RTLIL representation for module `\GTXE2_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE2'.
Generating RTLIL representation for module `\GTHE3_CHANNEL'.
Generating RTLIL representation for module `\GTHE3_COMMON'.
Generating RTLIL representation for module `\GTHE4_CHANNEL'.
Generating RTLIL representation for module `\GTHE4_COMMON'.
Generating RTLIL representation for module `\GTYE3_CHANNEL'.
Generating RTLIL representation for module `\GTYE3_COMMON'.
Generating RTLIL representation for module `\GTYE4_CHANNEL'.
Generating RTLIL representation for module `\GTYE4_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE3'.
Generating RTLIL representation for module `\IBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE3'.
Generating RTLIL representation for module `\OBUFDS_GTE3_ADV'.
Generating RTLIL representation for module `\OBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE4_ADV'.
Generating RTLIL representation for module `\PCIE_A1'.
Generating RTLIL representation for module `\PCIE_EP'.
Generating RTLIL representation for module `\PCIE_2_0'.
Generating RTLIL representation for module `\PCIE_2_1'.
Generating RTLIL representation for module `\PCIE_3_0'.
Generating RTLIL representation for module `\PCIE_3_1'.
Generating RTLIL representation for module `\PCIE40E4'.
Generating RTLIL representation for module `\EMAC'.
Generating RTLIL representation for module `\TEMAC'.
Generating RTLIL representation for module `\TEMAC_SINGLE'.
Generating RTLIL representation for module `\CMAC'.
Generating RTLIL representation for module `\CMACE4'.
Generating RTLIL representation for module `\PPC405_ADV'.
Generating RTLIL representation for module `\PPC440'.
Generating RTLIL representation for module `\MCB'.
Generating RTLIL representation for module `\PS7'.
Generating RTLIL representation for module `\PS8'.
Generating RTLIL representation for module `\ILKN'.
Generating RTLIL representation for module `\ILKNE4'.
Successfully finished Verilog frontend.

3.3. Executing HIERARCHY pass (managing design hierarchy).

3.3.1. Analyzing design hierarchy..
Top module:  \block_ram

3.3.2. Analyzing design hierarchy..
Top module:  \block_ram
Removed 0 unused modules.

3.4. Executing PROC pass (convert processes to netlists).

3.4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

3.4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.4.4. Executing PROC_INIT pass (extract init attributes).

3.4.5. Executing PROC_ARST pass (detect async resets in processes).

3.4.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\block_ram.$proc$attributes_test.v:14$2'.
     1/3: $0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5
     2/3: $0$memwr$\memory$attributes_test.v:16$1_DATA[3:0]$4
     3/3: $0$memwr$\memory$attributes_test.v:16$1_ADDR[9:0]$3

3.4.7. Executing PROC_DLATCH pass (convert process syncs to latches).

3.4.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\block_ram.\data_out_r' using process `\block_ram.$proc$attributes_test.v:14$2'.
  created $dff cell `$procdff$48' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$1_ADDR' using process `\block_ram.$proc$attributes_test.v:14$2'.
  created $dff cell `$procdff$49' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$1_DATA' using process `\block_ram.$proc$attributes_test.v:14$2'.
  created $dff cell `$procdff$50' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$1_EN' using process `\block_ram.$proc$attributes_test.v:14$2'.
  created $dff cell `$procdff$51' with positive edge clock.

3.4.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\block_ram.$proc$attributes_test.v:14$2'.
Removing empty process `block_ram.$proc$attributes_test.v:14$2'.
Cleaned up 1 empty switch.

3.5. Executing TRIBUF pass.

3.6. Executing DEMINOUT pass (demote inout ports to input or output).

3.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Removed 0 unused cells and 7 unused wires.
<suppressed ~1 debug messages>

3.9. Executing CHECK pass (checking for obvious problems).
checking module block_ram..
found and reported 0 problems.

3.10. Executing OPT pass (performing simple optimizations).

3.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

3.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
    Consolidated identical input bits for $mux cell $procmux$42:
      Old ports: A=4'0000, B=4'1111, Y=$0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5 [0]
      New connections: $0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5 [3:1] = { $0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5 [0] $0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5 [0] $0$memwr$\memory$attributes_test.v:16$1_EN[3:0]$5 [0] }
  Optimizing cells in module \block_ram.
Performed a total of 1 changes.

3.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.10.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.10.9. Rerunning OPT passes. (Maybe there is more to do..)

3.10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

3.10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
Performed a total of 0 changes.

3.10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.10.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.10.16. Finished OPT passes. (There is nothing left to do.)

3.11. Executing WREDUCE pass (reducing word size of cells).
Removed cell block_ram.$procmux$44 ($mux).
Removed cell block_ram.$procmux$46 ($mux).
Removed top 3 bits (of 4) from FF cell block_ram.$procdff$51 ($dff).

3.12. Executing PEEPOPT pass (run peephole optimizers).

3.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

3.14. Executing PMUX2SHIFTX pass.

3.15. Executing TECHMAP pass (map to technology primitives).

3.15.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

3.15.2. Continuing TECHMAP pass.
No more expansions possible.

3.16. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$memwr$\memory$attributes_test.v:16$7' in module `\block_ram': merged $dff to cell.
Checking cell `$memrd$\memory$attributes_test.v:17$6' in module `\block_ram': merged data $dff to cell.

3.17. Executing TECHMAP pass (map to technology primitives).

3.17.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v' to AST representation.
Generating RTLIL representation for module `\_80_mul'.
Generating RTLIL representation for module `\_90_soft_mul'.
Successfully finished Verilog frontend.

3.17.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v' to AST representation.
Generating RTLIL representation for module `\$__MUL25X18'.
Successfully finished Verilog frontend.

3.17.3. Continuing TECHMAP pass.
No more expansions possible.

3.18. Executing OPT_EXPR pass (perform const folding).

3.19. Executing WREDUCE pass (reducing word size of cells).

3.20. Executing XILINX_DSP pass (pack resources into DSPs).

3.21. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module block_ram:
  created 0 $alu and 0 $macc cells.

3.22. Executing SHARE pass (SAT-based resource sharing).

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.23.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.23.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
Performed a total of 0 changes.

3.23.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.23.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.23.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Removed 4 unused cells and 5 unused wires.
<suppressed ~5 debug messages>

3.23.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.23.9. Rerunning OPT passes. (Maybe there is more to do..)

3.23.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.23.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
Performed a total of 0 changes.

3.23.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.23.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.23.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.23.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.23.16. Finished OPT passes. (There is nothing left to do.)

3.24. Executing FSM pass (extract and optimize FSM).

3.24.1. Executing FSM_DETECT pass (finding FSMs in design).

3.24.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.24.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.24.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.24.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.24.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.24.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.25. Executing OPT pass (performing simple optimizations).

3.25.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.25.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.25.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.25.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.25.5. Finished fast OPT passes.

3.26. Executing MEMORY pass.

3.26.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.26.2. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

3.26.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.26.4. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.26.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.26.6. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\block_ram':
  $memwr$\memory$attributes_test.v:16$7 ($memwr)
  $memrd$\memory$attributes_test.v:17$6 ($memrd)

3.27. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.28. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing block_ram.memory:
  Properties: ports=2 bits=4096 rports=1 wports=1 dbits=4 abits=10 words=1024
  Checking rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1):
    Bram geometry: abits=9 dbits=72 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_SDP: awaste=0 dwaste=68 bwaste=34816 waste=34816 efficiency=5
    Rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1) accepted.
    Mapping to bram type $__XILINX_RAMB36_SDP (variant 1):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=34816 efficiency=5
      Storing for later selection.
  Checking rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1):
    Bram geometry: abits=9 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_SDP: awaste=0 dwaste=32 bwaste=16384 waste=16384 efficiency=11
    Rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1) accepted.
    Mapping to bram type $__XILINX_RAMB18_SDP (variant 1):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=16384 efficiency=11
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1):
    Bram geometry: abits=10 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=0 dwaste=32 bwaste=32768 waste=32768 efficiency=11
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1) accepted.
    Mapping to bram type $__XILINX_RAMB36_TDP (variant 1):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=32768 efficiency=11
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2):
    Bram geometry: abits=11 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=1024 dwaste=14 bwaste=32768 waste=32768 efficiency=11
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2) accepted.
    Mapping to bram type $__XILINX_RAMB36_TDP (variant 2):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=32768 efficiency=11
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3):
    Bram geometry: abits=12 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=3072 dwaste=5 bwaste=32768 waste=32768 efficiency=11
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3) accepted.
    Mapping to bram type $__XILINX_RAMB36_TDP (variant 3):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=32768 efficiency=11
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4):
    Bram geometry: abits=13 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=7168 dwaste=0 bwaste=28672 waste=28672 efficiency=12
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4) accepted.
    Mapping to bram type $__XILINX_RAMB36_TDP (variant 4):
      Shuffle bit order to accommodate enable buckets of size 4..
      Results of bit order shuffling: 0 1 2 3
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=28672 efficiency=12
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5):
    Bram geometry: abits=14 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=15360 dwaste=0 bwaste=30720 waste=30720 efficiency=6
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5) accepted.
    Mapping to bram type $__XILINX_RAMB36_TDP (variant 5):
      Shuffle bit order to accommodate enable buckets of size 2..
      Results of bit order shuffling: 0 1 2 3
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=30720 efficiency=6
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6):
    Bram geometry: abits=15 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=31744 dwaste=0 bwaste=31744 waste=31744 efficiency=3
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1):
    Bram geometry: abits=10 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=0 dwaste=14 bwaste=14336 waste=14336 efficiency=22
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1) accepted.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 1):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=14336 efficiency=22
      Storing for later selection.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2):
    Bram geometry: abits=11 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=1024 dwaste=5 bwaste=14336 waste=14336 efficiency=22
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2) accepted.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 2):
      Shuffle bit order to accommodate enable buckets of size 9..
      Results of bit order shuffling: 0 1 2 3 -1 -1 -1 -1 -1
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=14336 efficiency=22
      Storing for later selection.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3):
    Bram geometry: abits=12 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=3072 dwaste=0 bwaste=12288 waste=12288 efficiency=25
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3) accepted.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 3):
      Shuffle bit order to accommodate enable buckets of size 4..
      Results of bit order shuffling: 0 1 2 3
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=12288 efficiency=25
      Storing for later selection.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4):
    Bram geometry: abits=13 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=7168 dwaste=0 bwaste=14336 waste=14336 efficiency=12
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4) accepted.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 4):
      Shuffle bit order to accommodate enable buckets of size 2..
      Results of bit order shuffling: 0 1 2 3
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=14336 efficiency=12
      Storing for later selection.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5):
    Bram geometry: abits=14 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=15360 dwaste=0 bwaste=15360 waste=15360 efficiency=6
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5) accepted.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 5):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=15360 efficiency=6
      Storing for later selection.
  Selecting best of 12 rules:
    Efficiency for rule 4.5: efficiency=6, cells=4, acells=1
    Efficiency for rule 4.4: efficiency=12, cells=2, acells=1
    Efficiency for rule 4.3: efficiency=25, cells=1, acells=1
    Efficiency for rule 4.2: efficiency=22, cells=1, acells=1
    Efficiency for rule 4.1: efficiency=22, cells=1, acells=1
    Efficiency for rule 3.5: efficiency=6, cells=2, acells=1
    Efficiency for rule 3.4: efficiency=12, cells=1, acells=1
    Efficiency for rule 3.3: efficiency=11, cells=1, acells=1
    Efficiency for rule 3.2: efficiency=11, cells=1, acells=1
    Efficiency for rule 3.1: efficiency=11, cells=1, acells=1
    Efficiency for rule 2.1: efficiency=11, cells=2, acells=2
    Efficiency for rule 1.1: efficiency=5, cells=2, acells=2
    Selected rule 4.3 with efficiency 25.
    Mapping to bram type $__XILINX_RAMB18_TDP (variant 3):
      Shuffle bit order to accommodate enable buckets of size 4..
      Results of bit order shuffling: 0 1 2 3
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Creating $__XILINX_RAMB18_TDP cell at grid position <0 0 0>: memory.0.0.0

3.29. Executing TECHMAP pass (map to technology primitives).

3.29.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_brams_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAMB36_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB36_TDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_TDP'.
Successfully finished Verilog frontend.

3.29.2. Continuing TECHMAP pass.
Using template $paramod\$__XILINX_RAMB18_TDP\CFG_ABITS=12\CFG_DBITS=4\CFG_ENABLE_B=1\CLKPOL2=1\CLKPOL3=1 for cells of type $__XILINX_RAMB18_TDP.
No more expansions possible.
<suppressed ~20 debug messages>

3.30. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).

3.31. Executing TECHMAP pass (map to technology primitives).

3.31.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lutrams_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lutrams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAM32X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM64X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM128X1D'.
Successfully finished Verilog frontend.

3.31.2. Continuing TECHMAP pass.
No more expansions possible.

3.32. Executing OPT pass (performing simple optimizations).

3.32.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.
<suppressed ~3 debug messages>

3.32.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.32.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.32.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Removed 0 unused cells and 17 unused wires.
<suppressed ~1 debug messages>

3.32.5. Finished fast OPT passes.

3.33. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

3.34. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

3.35. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Transforming FF to FF+Enable cells in module block_ram:

3.36. Executing OPT pass (performing simple optimizations).

3.36.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.36.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.36.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

3.36.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
Performed a total of 0 changes.

3.36.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.36.6. Executing OPT_SHARE pass.

3.36.7. Executing OPT_RMDFF pass (remove dff with constant values).

3.36.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.36.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.36.10. Finished OPT passes. (There is nothing left to do.)

3.37. Executing XILINX_SRL pass (Xilinx shift register extraction).

3.38. Executing TECHMAP pass (map to technology primitives).

3.38.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.38.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/arith_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_xilinx_lcu'.
Generating RTLIL representation for module `\_80_xilinx_alu'.
Successfully finished Verilog frontend.

3.38.3. Continuing TECHMAP pass.
No more expansions possible.

3.39. Executing OPT pass (performing simple optimizations).

3.39.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.39.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

3.39.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.39.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

3.39.5. Finished fast OPT passes.

3.40. Executing TECHMAP pass (map to technology primitives).

3.40.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.40.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Generating RTLIL representation for module `\$__XILINX_MUXF78'.
Generating RTLIL representation for module `\$__XILINX_TINOUTPAD'.
Generating RTLIL representation for module `\$__XILINX_TOUTPAD'.
Successfully finished Verilog frontend.

3.40.3. Continuing TECHMAP pass.
No more expansions possible.

3.41. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

3.42. Executing ABC pass (technology mapping using ABC).

3.42.1. Extracting gate netlist of module `\block_ram' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.43. Executing XILINX_SRL pass (Xilinx shift register extraction).

3.44. Executing TECHMAP pass (map to technology primitives).

3.44.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lut_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lut_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

3.44.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Generating RTLIL representation for module `\$__XILINX_MUXF78'.
Generating RTLIL representation for module `\$__XILINX_TINOUTPAD'.
Generating RTLIL representation for module `\$__XILINX_TOUTPAD'.
Successfully finished Verilog frontend.

3.44.3. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_ff_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

3.44.4. Continuing TECHMAP pass.
No more expansions possible.

3.45. Executing CLKBUFMAP pass (inserting global clock buffers).
Inserting BUFG on block_ram.clk[0].

3.46. Executing HIERARCHY pass (managing design hierarchy).

3.46.1. Analyzing design hierarchy..
Top module:  \block_ram

3.46.2. Analyzing design hierarchy..
Top module:  \block_ram
Removed 0 unused modules.

3.47. Printing statistics.

=== block_ram ===

   Number of wires:                 12
   Number of wire bits:             62
   Number of public wires:           6
   Number of public wire bits:      24
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     BUFG                            1
     RAMB18E1                        1

   Estimated number of LCs:          0

3.48. Executing CHECK pass (checking for obvious problems).
checking module block_ram..
found and reported 0 problems.

4. Executing Verilog-2005 frontend: attributes_test.v
Parsing Verilog input from `attributes_test.v' to AST representation.
Generating RTLIL representation for module `\block_ram'.
Generating RTLIL representation for module `\distributed_ram'.
Generating RTLIL representation for module `\distributed_ram_manual'.
Generating RTLIL representation for module `\distributed_ram_manual_syn'.
Successfully finished Verilog frontend.

5. Executing HIERARCHY pass (managing design hierarchy).

5.1. Analyzing design hierarchy..
Top module:  \distributed_ram

5.2. Analyzing design hierarchy..
Top module:  \distributed_ram
Removing unused module `\distributed_ram_manual_syn'.
Removing unused module `\distributed_ram_manual'.
Removing unused module `\block_ram'.
Removed 3 unused modules.

6. Executing SYNTH_XILINX pass.

6.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\VCC'.
Generating RTLIL representation for module `\GND'.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\IBUFG'.
Generating RTLIL representation for module `\OBUF'.
Generating RTLIL representation for module `\IOBUF'.
Generating RTLIL representation for module `\OBUFT'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGCTRL'.
Generating RTLIL representation for module `\BUFHCE'.
Generating RTLIL representation for module `\INV'.
Generating RTLIL representation for module `\LUT1'.
Generating RTLIL representation for module `\LUT2'.
Generating RTLIL representation for module `\LUT3'.
Generating RTLIL representation for module `\LUT4'.
Generating RTLIL representation for module `\LUT5'.
Generating RTLIL representation for module `\LUT6'.
Generating RTLIL representation for module `\LUT6_2'.
Generating RTLIL representation for module `\MUXCY'.
Generating RTLIL representation for module `\MUXF7'.
Generating RTLIL representation for module `\MUXF8'.
Generating RTLIL representation for module `\XORCY'.
Generating RTLIL representation for module `\CARRY4'.
Generating RTLIL representation for module `\FDRE'.
Generating RTLIL representation for module `\FDSE'.
Generating RTLIL representation for module `\FDCE'.
Generating RTLIL representation for module `\FDPE'.
Generating RTLIL representation for module `\FDRE_1'.
Generating RTLIL representation for module `\FDSE_1'.
Generating RTLIL representation for module `\FDCE_1'.
Generating RTLIL representation for module `\FDPE_1'.
Generating RTLIL representation for module `\LDCE'.
Generating RTLIL representation for module `\LDPE'.
Generating RTLIL representation for module `\RAM16X1S'.
Generating RTLIL representation for module `\RAM16X1S_1'.
Generating RTLIL representation for module `\RAM32X1S'.
Generating RTLIL representation for module `\RAM32X1S_1'.
Generating RTLIL representation for module `\RAM64X1S'.
Generating RTLIL representation for module `\RAM64X1S_1'.
Generating RTLIL representation for module `\RAM128X1S'.
Generating RTLIL representation for module `\RAM128X1S_1'.
Generating RTLIL representation for module `\RAM256X1S'.
Generating RTLIL representation for module `\RAM512X1S'.
Generating RTLIL representation for module `\RAM16X2S'.
Generating RTLIL representation for module `\RAM32X2S'.
Generating RTLIL representation for module `\RAM64X2S'.
Generating RTLIL representation for module `\RAM16X4S'.
Generating RTLIL representation for module `\RAM32X4S'.
Generating RTLIL representation for module `\RAM16X8S'.
Generating RTLIL representation for module `\RAM32X8S'.
Generating RTLIL representation for module `\RAM16X1D'.
Generating RTLIL representation for module `\RAM16X1D_1'.
Generating RTLIL representation for module `\RAM32X1D'.
Generating RTLIL representation for module `\RAM32X1D_1'.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM64X1D_1'.
Generating RTLIL representation for module `\RAM128X1D'.
Generating RTLIL representation for module `\RAM256X1D'.
Generating RTLIL representation for module `\RAM32M'.
Generating RTLIL representation for module `\RAM32M16'.
Generating RTLIL representation for module `\RAM64M'.
Generating RTLIL representation for module `\RAM64M8'.
Generating RTLIL representation for module `\ROM16X1'.
Generating RTLIL representation for module `\ROM32X1'.
Generating RTLIL representation for module `\ROM64X1'.
Generating RTLIL representation for module `\ROM128X1'.
Generating RTLIL representation for module `\ROM256X1'.
Generating RTLIL representation for module `\SRL16E'.
Generating RTLIL representation for module `\SRLC16E'.
Generating RTLIL representation for module `\SRLC32E'.
Generating RTLIL representation for module `\MULT18X18'.
Generating RTLIL representation for module `\MULT18X18S'.
Generating RTLIL representation for module `\MULT18X18SIO'.
Generating RTLIL representation for module `\DSP48A'.
Generating RTLIL representation for module `\DSP48A1'.
Generating RTLIL representation for module `\DSP48E1'.
Successfully finished Verilog frontend.

6.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v' to AST representation.
Generating RTLIL representation for module `\FDCPE'.
Generating RTLIL representation for module `\FDRSE'.
Generating RTLIL representation for module `\LDCPE'.
Generating RTLIL representation for module `\AND2B1L'.
Generating RTLIL representation for module `\OR2L'.
Generating RTLIL representation for module `\MUXF5'.
Generating RTLIL representation for module `\MUXF6'.
Generating RTLIL representation for module `\MUXF9'.
Generating RTLIL representation for module `\CARRY8'.
Generating RTLIL representation for module `\ORCY'.
Generating RTLIL representation for module `\MULT_AND'.
Generating RTLIL representation for module `\SRL16'.
Generating RTLIL representation for module `\SRLC16'.
Generating RTLIL representation for module `\CFGLUT5'.
Generating RTLIL representation for module `\RAMB16_S1'.
Generating RTLIL representation for module `\RAMB16_S2'.
Generating RTLIL representation for module `\RAMB16_S4'.
Generating RTLIL representation for module `\RAMB16_S9'.
Generating RTLIL representation for module `\RAMB16_S18'.
Generating RTLIL representation for module `\RAMB16_S36'.
Generating RTLIL representation for module `\RAMB16_S1_S1'.
Generating RTLIL representation for module `\RAMB16_S1_S2'.
Generating RTLIL representation for module `\RAMB16_S1_S4'.
Generating RTLIL representation for module `\RAMB16_S1_S9'.
Generating RTLIL representation for module `\RAMB16_S1_S18'.
Generating RTLIL representation for module `\RAMB16_S1_S36'.
Generating RTLIL representation for module `\RAMB16_S2_S2'.
Generating RTLIL representation for module `\RAMB16_S2_S4'.
Generating RTLIL representation for module `\RAMB16_S2_S9'.
Generating RTLIL representation for module `\RAMB16_S2_S18'.
Generating RTLIL representation for module `\RAMB16_S2_S36'.
Generating RTLIL representation for module `\RAMB16_S4_S4'.
Generating RTLIL representation for module `\RAMB16_S4_S9'.
Generating RTLIL representation for module `\RAMB16_S4_S18'.
Generating RTLIL representation for module `\RAMB16_S4_S36'.
Generating RTLIL representation for module `\RAMB16_S9_S9'.
Generating RTLIL representation for module `\RAMB16_S9_S18'.
Generating RTLIL representation for module `\RAMB16_S9_S36'.
Generating RTLIL representation for module `\RAMB16_S18_S18'.
Generating RTLIL representation for module `\RAMB16_S18_S36'.
Generating RTLIL representation for module `\RAMB16_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWER'.
Generating RTLIL representation for module `\RAMB8BWER'.
Generating RTLIL representation for module `\FIFO16'.
Generating RTLIL representation for module `\RAMB16'.
Generating RTLIL representation for module `\RAMB32_S64_ECC'.
Generating RTLIL representation for module `\FIFO18'.
Generating RTLIL representation for module `\FIFO18_36'.
Generating RTLIL representation for module `\FIFO36'.
Generating RTLIL representation for module `\FIFO36_72'.
Generating RTLIL representation for module `\RAMB18'.
Generating RTLIL representation for module `\RAMB36'.
Generating RTLIL representation for module `\RAMB18SDP'.
Generating RTLIL representation for module `\RAMB36SDP'.
Generating RTLIL representation for module `\FIFO18E1'.
Generating RTLIL representation for module `\FIFO36E1'.
Generating RTLIL representation for module `\RAMB18E1'.
Generating RTLIL representation for module `\RAMB36E1'.
Generating RTLIL representation for module `\FIFO18E2'.
Generating RTLIL representation for module `\FIFO36E2'.
Generating RTLIL representation for module `\RAMB18E2'.
Generating RTLIL representation for module `\RAMB36E2'.
Generating RTLIL representation for module `\URAM288'.
Generating RTLIL representation for module `\URAM288_BASE'.
Generating RTLIL representation for module `\DSP48'.
Generating RTLIL representation for module `\DSP48E'.
Generating RTLIL representation for module `\DSP48E2'.
Generating RTLIL representation for module `\IFDDRCPE'.
Generating RTLIL representation for module `\IFDDRRSE'.
Generating RTLIL representation for module `\OFDDRCPE'.
Generating RTLIL representation for module `\OFDDRRSE'.
Generating RTLIL representation for module `\OFDDRTCPE'.
Generating RTLIL representation for module `\OFDDRTRSE'.
Generating RTLIL representation for module `\IDDR2'.
Generating RTLIL representation for module `\ODDR2'.
Generating RTLIL representation for module `\IDDR'.
Generating RTLIL representation for module `\IDDR_2CLK'.
Generating RTLIL representation for module `\ODDR'.
Generating RTLIL representation for module `\IDELAYCTRL'.
Generating RTLIL representation for module `\IDELAY'.
Generating RTLIL representation for module `\ISERDES'.
Generating RTLIL representation for module `\OSERDES'.
Generating RTLIL representation for module `\IODELAY'.
Generating RTLIL representation for module `\ISERDES_NODELAY'.
Generating RTLIL representation for module `\IODELAYE1'.
Generating RTLIL representation for module `\ISERDESE1'.
Generating RTLIL representation for module `\OSERDESE1'.
Generating RTLIL representation for module `\IDELAYE2'.
Generating RTLIL representation for module `\ODELAYE2'.
Generating RTLIL representation for module `\ISERDESE2'.
Generating RTLIL representation for module `\OSERDESE2'.
Generating RTLIL representation for module `\PHASER_IN'.
Generating RTLIL representation for module `\PHASER_IN_PHY'.
Generating RTLIL representation for module `\PHASER_OUT'.
Generating RTLIL representation for module `\PHASER_OUT_PHY'.
Generating RTLIL representation for module `\PHASER_REF'.
Generating RTLIL representation for module `\PHY_CONTROL'.
Generating RTLIL representation for module `\IDDRE1'.
Generating RTLIL representation for module `\ODDRE1'.
Generating RTLIL representation for module `\IDELAYE3'.
Generating RTLIL representation for module `\ODELAYE3'.
Generating RTLIL representation for module `\ISERDESE3'.
Generating RTLIL representation for module `\OSERDESE3'.
Generating RTLIL representation for module `\BITSLICE_CONTROL'.
Generating RTLIL representation for module `\RIU_OR'.
Generating RTLIL representation for module `\RX_BITSLICE'.
Generating RTLIL representation for module `\RXTX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE_TRI'.
Generating RTLIL representation for module `\IODELAY2'.
Generating RTLIL representation for module `\IODRP2'.
Generating RTLIL representation for module `\IODRP2_MCB'.
Generating RTLIL representation for module `\ISERDES2'.
Generating RTLIL representation for module `\OSERDES2'.
Generating RTLIL representation for module `\IBUF_DLY_ADJ'.
Generating RTLIL representation for module `\IBUF_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUF_ANALOG'.
Generating RTLIL representation for module `\IBUFE3'.
Generating RTLIL representation for module `\IBUFDS'.
Generating RTLIL representation for module `\IBUFDS_DLY_ADJ'.
Generating RTLIL representation for module `\IBUFDS_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDSE3'.
Generating RTLIL representation for module `\IBUFDS_DPHY'.
Generating RTLIL representation for module `\IBUFGDS'.
Generating RTLIL representation for module `\IBUFGDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUF_DCIEN'.
Generating RTLIL representation for module `\IOBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFE3'.
Generating RTLIL representation for module `\IOBUFDS'.
Generating RTLIL representation for module `\IOBUFDS_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDSE3'.
Generating RTLIL representation for module `\OBUFDS'.
Generating RTLIL representation for module `\OBUFDS_DPHY'.
Generating RTLIL representation for module `\OBUFTDS'.
Generating RTLIL representation for module `\KEEPER'.
Generating RTLIL representation for module `\PULLDOWN'.
Generating RTLIL representation for module `\PULLUP'.
Generating RTLIL representation for module `\DCIRESET'.
Generating RTLIL representation for module `\HPIO_VREF'.
Generating RTLIL representation for module `\BUFGCE'.
Generating RTLIL representation for module `\BUFGCE_1'.
Generating RTLIL representation for module `\BUFGMUX'.
Generating RTLIL representation for module `\BUFGMUX_1'.
Generating RTLIL representation for module `\BUFGMUX_CTRL'.
Generating RTLIL representation for module `\BUFGMUX_VIRTEX4'.
Generating RTLIL representation for module `\BUFG_GT'.
Generating RTLIL representation for module `\BUFG_GT_SYNC'.
Generating RTLIL representation for module `\BUFG_PS'.
Generating RTLIL representation for module `\BUFGCE_DIV'.
Generating RTLIL representation for module `\BUFH'.
Generating RTLIL representation for module `\BUFIO2'.
Generating RTLIL representation for module `\BUFIO2_2CLK'.
Generating RTLIL representation for module `\BUFIO2FB'.
Generating RTLIL representation for module `\BUFPLL'.
Generating RTLIL representation for module `\BUFPLL_MCB'.
Generating RTLIL representation for module `\BUFIO'.
Generating RTLIL representation for module `\BUFIODQS'.
Generating RTLIL representation for module `\BUFR'.
Generating RTLIL representation for module `\BUFMR'.
Generating RTLIL representation for module `\BUFMRCE'.
Generating RTLIL representation for module `\DCM'.
Generating RTLIL representation for module `\DCM_SP'.
Generating RTLIL representation for module `\DCM_CLKGEN'.
Generating RTLIL representation for module `\DCM_ADV'.
Generating RTLIL representation for module `\DCM_BASE'.
Generating RTLIL representation for module `\DCM_PS'.
Generating RTLIL representation for module `\PMCD'.
Generating RTLIL representation for module `\PLL_ADV'.
Generating RTLIL representation for module `\PLL_BASE'.
Generating RTLIL representation for module `\MMCM_ADV'.
Generating RTLIL representation for module `\MMCM_BASE'.
Generating RTLIL representation for module `\MMCME2_ADV'.
Generating RTLIL representation for module `\MMCME2_BASE'.
Generating RTLIL representation for module `\PLLE2_ADV'.
Generating RTLIL representation for module `\PLLE2_BASE'.
Generating RTLIL representation for module `\MMCME3_ADV'.
Generating RTLIL representation for module `\MMCME3_BASE'.
Generating RTLIL representation for module `\PLLE3_ADV'.
Generating RTLIL representation for module `\PLLE3_BASE'.
Generating RTLIL representation for module `\MMCME4_ADV'.
Generating RTLIL representation for module `\MMCME4_BASE'.
Generating RTLIL representation for module `\PLLE4_ADV'.
Generating RTLIL representation for module `\PLLE4_BASE'.
Generating RTLIL representation for module `\BUFT'.
Generating RTLIL representation for module `\IN_FIFO'.
Generating RTLIL representation for module `\OUT_FIFO'.
Generating RTLIL representation for module `\HARD_SYNC'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3E'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3A'.
Generating RTLIL representation for module `\STARTUP_SPARTAN6'.
Generating RTLIL representation for module `\STARTUP_VIRTEX4'.
Generating RTLIL representation for module `\STARTUP_VIRTEX5'.
Generating RTLIL representation for module `\STARTUP_VIRTEX6'.
Generating RTLIL representation for module `\STARTUPE2'.
Generating RTLIL representation for module `\STARTUPE3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3A'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX4'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX5'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX6'.
Generating RTLIL representation for module `\CAPTUREE2'.
Generating RTLIL representation for module `\ICAP_SPARTAN3A'.
Generating RTLIL representation for module `\ICAP_SPARTAN6'.
Generating RTLIL representation for module `\ICAP_VIRTEX4'.
Generating RTLIL representation for module `\ICAP_VIRTEX5'.
Generating RTLIL representation for module `\ICAP_VIRTEX6'.
Generating RTLIL representation for module `\ICAPE2'.
Generating RTLIL representation for module `\ICAPE3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3A'.
Generating RTLIL representation for module `\BSCAN_SPARTAN6'.
Generating RTLIL representation for module `\BSCAN_VIRTEX4'.
Generating RTLIL representation for module `\BSCAN_VIRTEX5'.
Generating RTLIL representation for module `\BSCAN_VIRTEX6'.
Generating RTLIL representation for module `\BSCANE2'.
Generating RTLIL representation for module `\DNA_PORT'.
Generating RTLIL representation for module `\DNA_PORTE2'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX4'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX5'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX6'.
Generating RTLIL representation for module `\FRAME_ECCE2'.
Generating RTLIL representation for module `\FRAME_ECCE3'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX4'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX5'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX6'.
Generating RTLIL representation for module `\USR_ACCESSE2'.
Generating RTLIL representation for module `\POST_CRC_INTERNAL'.
Generating RTLIL representation for module `\SUSPEND_SYNC'.
Generating RTLIL representation for module `\KEY_CLEAR'.
Generating RTLIL representation for module `\MASTER_JTAG'.
Generating RTLIL representation for module `\SPI_ACCESS'.
Generating RTLIL representation for module `\EFUSE_USR'.
Generating RTLIL representation for module `\SYSMON'.
Generating RTLIL representation for module `\XADC'.
Generating RTLIL representation for module `\SYSMONE1'.
Generating RTLIL representation for module `\SYSMONE4'.
Generating RTLIL representation for module `\GTPA1_DUAL'.
Generating RTLIL representation for module `\GT11_CUSTOM'.
Generating RTLIL representation for module `\GT11_DUAL'.
Generating RTLIL representation for module `\GT11CLK'.
Generating RTLIL representation for module `\GT11CLK_MGT'.
Generating RTLIL representation for module `\GTP_DUAL'.
Generating RTLIL representation for module `\GTX_DUAL'.
Generating RTLIL representation for module `\CRC32'.
Generating RTLIL representation for module `\CRC64'.
Generating RTLIL representation for module `\GTHE1_QUAD'.
Generating RTLIL representation for module `\GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTHE1'.
Generating RTLIL representation for module `\GTHE2_CHANNEL'.
Generating RTLIL representation for module `\GTHE2_COMMON'.
Generating RTLIL representation for module `\GTPE2_CHANNEL'.
Generating RTLIL representation for module `\GTPE2_COMMON'.
Generating RTLIL representation for module `\GTXE2_CHANNEL'.
Generating RTLIL representation for module `\GTXE2_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE2'.
Generating RTLIL representation for module `\GTHE3_CHANNEL'.
Generating RTLIL representation for module `\GTHE3_COMMON'.
Generating RTLIL representation for module `\GTHE4_CHANNEL'.
Generating RTLIL representation for module `\GTHE4_COMMON'.
Generating RTLIL representation for module `\GTYE3_CHANNEL'.
Generating RTLIL representation for module `\GTYE3_COMMON'.
Generating RTLIL representation for module `\GTYE4_CHANNEL'.
Generating RTLIL representation for module `\GTYE4_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE3'.
Generating RTLIL representation for module `\IBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE3'.
Generating RTLIL representation for module `\OBUFDS_GTE3_ADV'.
Generating RTLIL representation for module `\OBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE4_ADV'.
Generating RTLIL representation for module `\PCIE_A1'.
Generating RTLIL representation for module `\PCIE_EP'.
Generating RTLIL representation for module `\PCIE_2_0'.
Generating RTLIL representation for module `\PCIE_2_1'.
Generating RTLIL representation for module `\PCIE_3_0'.
Generating RTLIL representation for module `\PCIE_3_1'.
Generating RTLIL representation for module `\PCIE40E4'.
Generating RTLIL representation for module `\EMAC'.
Generating RTLIL representation for module `\TEMAC'.
Generating RTLIL representation for module `\TEMAC_SINGLE'.
Generating RTLIL representation for module `\CMAC'.
Generating RTLIL representation for module `\CMACE4'.
Generating RTLIL representation for module `\PPC405_ADV'.
Generating RTLIL representation for module `\PPC440'.
Generating RTLIL representation for module `\MCB'.
Generating RTLIL representation for module `\PS7'.
Generating RTLIL representation for module `\PS8'.
Generating RTLIL representation for module `\ILKN'.
Generating RTLIL representation for module `\ILKNE4'.
Successfully finished Verilog frontend.

6.3. Executing HIERARCHY pass (managing design hierarchy).

6.3.1. Analyzing design hierarchy..
Top module:  \distributed_ram

6.3.2. Analyzing design hierarchy..
Top module:  \distributed_ram
Removed 0 unused modules.

6.4. Executing PROC pass (convert processes to netlists).

6.4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

6.4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

6.4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

6.4.4. Executing PROC_INIT pass (extract init attributes).

6.4.5. Executing PROC_ARST pass (detect async resets in processes).

6.4.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\distributed_ram.$proc$attributes_test.v:36$188'.
     1/3: $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191
     2/3: $0$memwr$\memory$attributes_test.v:38$187_DATA[7:0]$190
     3/3: $0$memwr$\memory$attributes_test.v:38$187_ADDR[3:0]$189

6.4.7. Executing PROC_DLATCH pass (convert process syncs to latches).

6.4.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\distributed_ram.\data_out_r' using process `\distributed_ram.$proc$attributes_test.v:36$188'.
  created $dff cell `$procdff$227' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$187_ADDR' using process `\distributed_ram.$proc$attributes_test.v:36$188'.
  created $dff cell `$procdff$228' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$187_DATA' using process `\distributed_ram.$proc$attributes_test.v:36$188'.
  created $dff cell `$procdff$229' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$187_EN' using process `\distributed_ram.$proc$attributes_test.v:36$188'.
  created $dff cell `$procdff$230' with positive edge clock.

6.4.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\distributed_ram.$proc$attributes_test.v:36$188'.
Removing empty process `distributed_ram.$proc$attributes_test.v:36$188'.
Cleaned up 1 empty switch.

6.5. Executing TRIBUF pass.

6.6. Executing DEMINOUT pass (demote inout ports to input or output).

6.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..
Removed 0 unused cells and 7 unused wires.
<suppressed ~1 debug messages>

6.9. Executing CHECK pass (checking for obvious problems).
checking module distributed_ram..
found and reported 0 problems.

6.10. Executing OPT pass (performing simple optimizations).

6.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

6.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \distributed_ram.
    Consolidated identical input bits for $mux cell $procmux$221:
      Old ports: A=8'00000000, B=8'11111111, Y=$0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0]
      New connections: $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [7:1] = { $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] $0$memwr$\memory$attributes_test.v:38$187_EN[7:0]$191 [0] }
  Optimizing cells in module \distributed_ram.
Performed a total of 1 changes.

6.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.10.6. Executing OPT_RMDFF pass (remove dff with constant values).

6.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.10.9. Rerunning OPT passes. (Maybe there is more to do..)

6.10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

6.10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \distributed_ram.
Performed a total of 0 changes.

6.10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.10.13. Executing OPT_RMDFF pass (remove dff with constant values).

6.10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.10.16. Finished OPT passes. (There is nothing left to do.)

6.11. Executing WREDUCE pass (reducing word size of cells).
Removed cell distributed_ram.$procmux$223 ($mux).
Removed cell distributed_ram.$procmux$225 ($mux).
Removed top 7 bits (of 8) from FF cell distributed_ram.$procdff$230 ($dff).

6.12. Executing PEEPOPT pass (run peephole optimizers).

6.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

6.14. Executing PMUX2SHIFTX pass.

6.15. Executing TECHMAP pass (map to technology primitives).

6.15.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

6.15.2. Continuing TECHMAP pass.
No more expansions possible.

6.16. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$memwr$\memory$attributes_test.v:38$193' in module `\distributed_ram': merged $dff to cell.
Checking cell `$memrd$\memory$attributes_test.v:39$192' in module `\distributed_ram': merged data $dff to cell.

6.17. Executing TECHMAP pass (map to technology primitives).

6.17.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v' to AST representation.
Generating RTLIL representation for module `\_80_mul'.
Generating RTLIL representation for module `\_90_soft_mul'.
Successfully finished Verilog frontend.

6.17.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v' to AST representation.
Generating RTLIL representation for module `\$__MUL25X18'.
Successfully finished Verilog frontend.

6.17.3. Continuing TECHMAP pass.
No more expansions possible.

6.18. Executing OPT_EXPR pass (perform const folding).

6.19. Executing WREDUCE pass (reducing word size of cells).

6.20. Executing XILINX_DSP pass (pack resources into DSPs).

6.21. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module distributed_ram:
  created 0 $alu and 0 $macc cells.

6.22. Executing SHARE pass (SAT-based resource sharing).

6.23. Executing OPT pass (performing simple optimizations).

6.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.23.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

6.23.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \distributed_ram.
Performed a total of 0 changes.

6.23.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.23.6. Executing OPT_RMDFF pass (remove dff with constant values).

6.23.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..
Removed 4 unused cells and 5 unused wires.
<suppressed ~5 debug messages>

6.23.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.23.9. Rerunning OPT passes. (Maybe there is more to do..)

6.23.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

6.23.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \distributed_ram.
Performed a total of 0 changes.

6.23.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.23.13. Executing OPT_RMDFF pass (remove dff with constant values).

6.23.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.23.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.23.16. Finished OPT passes. (There is nothing left to do.)

6.24. Executing FSM pass (extract and optimize FSM).

6.24.1. Executing FSM_DETECT pass (finding FSMs in design).

6.24.2. Executing FSM_EXTRACT pass (extracting FSM from design).

6.24.3. Executing FSM_OPT pass (simple optimizations of FSMs).

6.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.24.5. Executing FSM_OPT pass (simple optimizations of FSMs).

6.24.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

6.24.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

6.24.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

6.25. Executing OPT pass (performing simple optimizations).

6.25.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.25.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.25.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.25.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.25.5. Finished fast OPT passes.

6.26. Executing MEMORY pass.

6.26.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

6.26.2. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

6.26.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.26.4. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

6.26.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.26.6. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\distributed_ram':
  $memwr$\memory$attributes_test.v:38$193 ($memwr)
  $memrd$\memory$attributes_test.v:39$192 ($memrd)

6.27. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.28. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing distributed_ram.memory:
  Properties: ports=2 bits=128 rports=1 wports=1 dbits=8 abits=4 words=16
  Checking rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1):
    Bram geometry: abits=9 dbits=72 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_SDP: awaste=496 dwaste=64 bwaste=36736 waste=36736 efficiency=0
    Rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1):
    Bram geometry: abits=9 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_SDP: awaste=496 dwaste=28 bwaste=18304 waste=18304 efficiency=0
    Rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1):
    Bram geometry: abits=10 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=1008 dwaste=28 bwaste=36736 waste=36736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2):
    Bram geometry: abits=11 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=2032 dwaste=10 bwaste=36736 waste=36736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3):
    Bram geometry: abits=12 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=4080 dwaste=1 bwaste=36736 waste=36736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4):
    Bram geometry: abits=13 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=8176 dwaste=0 bwaste=32704 waste=32704 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5):
    Bram geometry: abits=14 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=16368 dwaste=0 bwaste=32736 waste=32736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6):
    Bram geometry: abits=15 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=32752 dwaste=0 bwaste=32752 waste=32752 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1):
    Bram geometry: abits=10 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=1008 dwaste=10 bwaste=18304 waste=18304 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2):
    Bram geometry: abits=11 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=2032 dwaste=1 bwaste=18304 waste=18304 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3):
    Bram geometry: abits=12 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=4080 dwaste=0 bwaste=16320 waste=16320 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4):
    Bram geometry: abits=13 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=8176 dwaste=0 bwaste=16352 waste=16352 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5):
    Bram geometry: abits=14 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=16368 dwaste=0 bwaste=16368 waste=16368 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  No acceptable bram resources found.

6.29. Executing TECHMAP pass (map to technology primitives).

6.29.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_brams_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAMB36_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB36_TDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_TDP'.
Successfully finished Verilog frontend.

6.29.2. Continuing TECHMAP pass.
No more expansions possible.

6.30. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing distributed_ram.memory:
  Properties: ports=2 bits=128 rports=1 wports=1 dbits=8 abits=4 words=16
  Checking rule #1 for bram type $__XILINX_RAM32X1D (variant 1):
    Bram geometry: abits=5 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM32X1D: awaste=16 dwaste=0 bwaste=16 waste=16 efficiency=50
    Rule #1 for bram type $__XILINX_RAM32X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=16 efficiency=50
      Storing for later selection.
  Checking rule #2 for bram type $__XILINX_RAM64X1D (variant 1):
    Bram geometry: abits=6 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM64X1D: awaste=48 dwaste=0 bwaste=48 waste=48 efficiency=25
    Rule #2 for bram type $__XILINX_RAM64X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM64X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=48 efficiency=25
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAM128X1D (variant 1):
    Bram geometry: abits=7 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM128X1D: awaste=112 dwaste=0 bwaste=112 waste=112 efficiency=12
    Rule #3 for bram type $__XILINX_RAM128X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM128X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Updated properties: dups=1 waste=112 efficiency=12
      Storing for later selection.
  Selecting best of 3 rules:
    Efficiency for rule 3.1: efficiency=12, cells=8, acells=1
    Efficiency for rule 2.1: efficiency=25, cells=8, acells=1
    Efficiency for rule 1.1: efficiency=50, cells=8, acells=1
    Selected rule 1.1 with efficiency 50.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain \clk.
        Mapped to bram port A1.1.
      Creating $__XILINX_RAM32X1D cell at grid position <0 0 0>: memory.0.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <1 0 0>: memory.1.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <2 0 0>: memory.2.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <3 0 0>: memory.3.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <4 0 0>: memory.4.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <5 0 0>: memory.5.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <6 0 0>: memory.6.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <7 0 0>: memory.7.0.0

6.31. Executing TECHMAP pass (map to technology primitives).

6.31.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lutrams_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lutrams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAM32X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM64X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM128X1D'.
Successfully finished Verilog frontend.

6.31.2. Continuing TECHMAP pass.
Using template $paramod\$__XILINX_RAM32X1D\CLKPOL2=1 for cells of type $__XILINX_RAM32X1D.
No more expansions possible.
<suppressed ~19 debug messages>

6.32. Executing OPT pass (performing simple optimizations).

6.32.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.
<suppressed ~9 debug messages>

6.32.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.32.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.32.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..
Removed 0 unused cells and 65 unused wires.
<suppressed ~1 debug messages>

6.32.5. Finished fast OPT passes.

6.33. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

6.34. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

6.35. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Transforming FF to FF+Enable cells in module distributed_ram:

6.36. Executing OPT pass (performing simple optimizations).

6.36.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.36.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.36.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

6.36.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \distributed_ram.
Performed a total of 0 changes.

6.36.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.36.6. Executing OPT_SHARE pass.

6.36.7. Executing OPT_RMDFF pass (remove dff with constant values).

6.36.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.36.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.36.10. Finished OPT passes. (There is nothing left to do.)

6.37. Executing XILINX_SRL pass (Xilinx shift register extraction).

6.38. Executing TECHMAP pass (map to technology primitives).

6.38.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

6.38.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/arith_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_xilinx_lcu'.
Generating RTLIL representation for module `\_80_xilinx_alu'.
Successfully finished Verilog frontend.

6.38.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $dff.
No more expansions possible.
<suppressed ~8 debug messages>

6.39. Executing OPT pass (performing simple optimizations).

6.39.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.39.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\distributed_ram'.
Removed a total of 0 cells.

6.39.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.39.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram..

6.39.5. Finished fast OPT passes.

6.40. Executing TECHMAP pass (map to technology primitives).

6.40.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

6.40.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Generating RTLIL representation for module `\$__XILINX_MUXF78'.
Generating RTLIL representation for module `\$__XILINX_TINOUTPAD'.
Generating RTLIL representation for module `\$__XILINX_TOUTPAD'.
Successfully finished Verilog frontend.

6.40.3. Continuing TECHMAP pass.
No more expansions possible.

6.41. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram.

6.42. Executing ABC pass (technology mapping using ABC).

6.42.1. Extracting gate netlist of module `\distributed_ram' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.43. Executing XILINX_SRL pass (Xilinx shift register extraction).

6.44. Executing TECHMAP pass (map to technology primitives).

6.44.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lut_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/lut_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

6.44.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Generating RTLIL representation for module `\$__XILINX_MUXF78'.
Generating RTLIL representation for module `\$__XILINX_TINOUTPAD'.
Generating RTLIL representation for module `\$__XILINX_TOUTPAD'.
Successfully finished Verilog frontend.

6.44.3. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_ff_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

6.44.4. Continuing TECHMAP pass.
Using template $paramod\$_DFF_P_\_TECHMAP_WIREINIT_Q_=1'x for cells of type $_DFF_P_.
No more expansions possible.
<suppressed ~19 debug messages>
Removed 0 unused cells and 32 unused wires.

6.45. Executing CLKBUFMAP pass (inserting global clock buffers).
Inserting BUFG on distributed_ram.clk[0].

6.46. Executing HIERARCHY pass (managing design hierarchy).

6.46.1. Analyzing design hierarchy..
Top module:  \distributed_ram

6.46.2. Analyzing design hierarchy..
Top module:  \distributed_ram
Removed 0 unused modules.

6.47. Printing statistics.

=== distributed_ram ===

   Number of wires:                 16
   Number of wire bits:             40
   Number of public wires:           6
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 17
     BUFG                            1
     FDRE                            8
     RAM32X1D                        8

   Estimated number of LCs:          0

6.48. Executing CHECK pass (checking for obvious problems).
checking module distributed_ram..
found and reported 0 problems.

7. Executing Verilog-2005 frontend: attributes_test.v
Parsing Verilog input from `attributes_test.v' to AST representation.
Generating RTLIL representation for module `\block_ram'.
Generating RTLIL representation for module `\distributed_ram'.
Generating RTLIL representation for module `\distributed_ram_manual'.
Generating RTLIL representation for module `\distributed_ram_manual_syn'.
Successfully finished Verilog frontend.

8. Executing PREP pass.

8.1. Executing HIERARCHY pass (managing design hierarchy).

8.2. Executing PROC pass (convert processes to netlists).

8.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

8.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

8.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 4 assignments to connections.

8.2.4. Executing PROC_INIT pass (extract init attributes).

8.2.5. Executing PROC_ARST pass (detect async resets in processes).

8.2.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
     1/3: $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443
     2/3: $0$memwr$\memory$attributes_test.v:82$440_DATA[7:0]$444
     3/3: $0$memwr$\memory$attributes_test.v:82$440_ADDR[3:0]$442
Creating decoders for process `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
     1/3: $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435
     2/3: $0$memwr$\memory$attributes_test.v:60$433_DATA[7:0]$437
     3/3: $0$memwr$\memory$attributes_test.v:60$433_ADDR[3:0]$436
Creating decoders for process `\distributed_ram.$proc$attributes_test.v:36$427'.
     1/3: $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430
     2/3: $0$memwr$\memory$attributes_test.v:38$426_DATA[7:0]$429
     3/3: $0$memwr$\memory$attributes_test.v:38$426_ADDR[3:0]$428
Creating decoders for process `\block_ram.$proc$attributes_test.v:14$420'.
     1/3: $0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423
     2/3: $0$memwr$\memory$attributes_test.v:16$419_DATA[3:0]$422
     3/3: $0$memwr$\memory$attributes_test.v:16$419_ADDR[9:0]$421

8.2.7. Executing PROC_DLATCH pass (convert process syncs to latches).

8.2.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\distributed_ram_manual_syn.$memwr$\memory$attributes_test.v:82$440_ADDR' using process `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
  created $dff cell `$procdff$471' with positive edge clock.
Creating register for signal `\distributed_ram_manual_syn.\data_out_r' using process `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
  created $dff cell `$procdff$472' with positive edge clock.
Creating register for signal `\distributed_ram_manual_syn.$memwr$\memory$attributes_test.v:82$440_EN' using process `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
  created $dff cell `$procdff$473' with positive edge clock.
Creating register for signal `\distributed_ram_manual_syn.$memwr$\memory$attributes_test.v:82$440_DATA' using process `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
  created $dff cell `$procdff$474' with positive edge clock.
Creating register for signal `\distributed_ram_manual.$memwr$\memory$attributes_test.v:60$433_EN' using process `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
  created $dff cell `$procdff$475' with positive edge clock.
Creating register for signal `\distributed_ram_manual.$memwr$\memory$attributes_test.v:60$433_ADDR' using process `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
  created $dff cell `$procdff$476' with positive edge clock.
Creating register for signal `\distributed_ram_manual.$memwr$\memory$attributes_test.v:60$433_DATA' using process `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
  created $dff cell `$procdff$477' with positive edge clock.
Creating register for signal `\distributed_ram_manual.\data_out_r' using process `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
  created $dff cell `$procdff$478' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$426_ADDR' using process `\distributed_ram.$proc$attributes_test.v:36$427'.
  created $dff cell `$procdff$479' with positive edge clock.
Creating register for signal `\distributed_ram.\data_out_r' using process `\distributed_ram.$proc$attributes_test.v:36$427'.
  created $dff cell `$procdff$480' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$426_DATA' using process `\distributed_ram.$proc$attributes_test.v:36$427'.
  created $dff cell `$procdff$481' with positive edge clock.
Creating register for signal `\distributed_ram.$memwr$\memory$attributes_test.v:38$426_EN' using process `\distributed_ram.$proc$attributes_test.v:36$427'.
  created $dff cell `$procdff$482' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$419_ADDR' using process `\block_ram.$proc$attributes_test.v:14$420'.
  created $dff cell `$procdff$483' with positive edge clock.
Creating register for signal `\block_ram.\data_out_r' using process `\block_ram.$proc$attributes_test.v:14$420'.
  created $dff cell `$procdff$484' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$419_DATA' using process `\block_ram.$proc$attributes_test.v:14$420'.
  created $dff cell `$procdff$485' with positive edge clock.
Creating register for signal `\block_ram.$memwr$\memory$attributes_test.v:16$419_EN' using process `\block_ram.$proc$attributes_test.v:14$420'.
  created $dff cell `$procdff$486' with positive edge clock.

8.2.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
Removing empty process `distributed_ram_manual_syn.$proc$attributes_test.v:80$441'.
Found and cleaned up 1 empty switch in `\distributed_ram_manual.$proc$attributes_test.v:58$434'.
Removing empty process `distributed_ram_manual.$proc$attributes_test.v:58$434'.
Found and cleaned up 1 empty switch in `\distributed_ram.$proc$attributes_test.v:36$427'.
Removing empty process `distributed_ram.$proc$attributes_test.v:36$427'.
Found and cleaned up 1 empty switch in `\block_ram.$proc$attributes_test.v:14$420'.
Removing empty process `block_ram.$proc$attributes_test.v:14$420'.
Cleaned up 4 empty switches.

8.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module distributed_ram_manual_syn.
Optimizing module distributed_ram_manual.
Optimizing module distributed_ram.
Optimizing module block_ram.

8.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \distributed_ram_manual_syn..
Finding unused cells or wires in module \distributed_ram_manual..
Finding unused cells or wires in module \distributed_ram..
Finding unused cells or wires in module \block_ram..
Removed 0 unused cells and 28 unused wires.
<suppressed ~4 debug messages>

8.5. Executing CHECK pass (checking for obvious problems).
checking module block_ram..
checking module distributed_ram..
checking module distributed_ram_manual..
checking module distributed_ram_manual_syn..
found and reported 0 problems.

8.6. Executing OPT pass (performing simple optimizations).

8.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.
Optimizing module distributed_ram.
Optimizing module distributed_ram_manual.
Optimizing module distributed_ram_manual_syn.

8.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Finding identical cells in module `\distributed_ram'.
Finding identical cells in module `\distributed_ram_manual'.
Finding identical cells in module `\distributed_ram_manual_syn'.
Removed a total of 0 cells.

8.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram_manual..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram_manual_syn..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

8.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
    Consolidated identical input bits for $mux cell $procmux$465:
      Old ports: A=4'0000, B=4'1111, Y=$0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423 [0]
      New connections: $0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423 [3:1] = { $0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423 [0] $0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423 [0] $0$memwr$\memory$attributes_test.v:16$419_EN[3:0]$423 [0] }
  Optimizing cells in module \block_ram.
  Optimizing cells in module \distributed_ram.
    Consolidated identical input bits for $mux cell $procmux$459:
      Old ports: A=8'00000000, B=8'11111111, Y=$0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0]
      New connections: $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [7:1] = { $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] $0$memwr$\memory$attributes_test.v:38$426_EN[7:0]$430 [0] }
  Optimizing cells in module \distributed_ram.
  Optimizing cells in module \distributed_ram_manual.
    Consolidated identical input bits for $mux cell $procmux$453:
      Old ports: A=8'00000000, B=8'11111111, Y=$0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0]
      New connections: $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [7:1] = { $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] $0$memwr$\memory$attributes_test.v:60$433_EN[7:0]$435 [0] }
  Optimizing cells in module \distributed_ram_manual.
  Optimizing cells in module \distributed_ram_manual_syn.
    Consolidated identical input bits for $mux cell $procmux$447:
      Old ports: A=8'00000000, B=8'11111111, Y=$0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443
      New ports: A=1'0, B=1'1, Y=$0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0]
      New connections: $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [7:1] = { $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] $0$memwr$\memory$attributes_test.v:82$440_EN[7:0]$443 [0] }
  Optimizing cells in module \distributed_ram_manual_syn.
Performed a total of 4 changes.

8.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Finding identical cells in module `\distributed_ram'.
Finding identical cells in module `\distributed_ram_manual'.
Finding identical cells in module `\distributed_ram_manual_syn'.
Removed a total of 0 cells.

8.6.6. Executing OPT_RMDFF pass (remove dff with constant values).

8.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Finding unused cells or wires in module \distributed_ram..
Finding unused cells or wires in module \distributed_ram_manual..
Finding unused cells or wires in module \distributed_ram_manual_syn..

8.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.
Optimizing module distributed_ram.
Optimizing module distributed_ram_manual.
Optimizing module distributed_ram_manual_syn.

8.6.9. Rerunning OPT passes. (Maybe there is more to do..)

8.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram_manual..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \distributed_ram_manual_syn..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

8.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
  Optimizing cells in module \distributed_ram.
  Optimizing cells in module \distributed_ram_manual.
  Optimizing cells in module \distributed_ram_manual_syn.
Performed a total of 0 changes.

8.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Finding identical cells in module `\distributed_ram'.
Finding identical cells in module `\distributed_ram_manual'.
Finding identical cells in module `\distributed_ram_manual_syn'.
Removed a total of 0 cells.

8.6.13. Executing OPT_RMDFF pass (remove dff with constant values).

8.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Finding unused cells or wires in module \distributed_ram..
Finding unused cells or wires in module \distributed_ram_manual..
Finding unused cells or wires in module \distributed_ram_manual_syn..

8.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.
Optimizing module distributed_ram.
Optimizing module distributed_ram_manual.
Optimizing module distributed_ram_manual_syn.

8.6.16. Finished OPT passes. (There is nothing left to do.)

8.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 3 bits (of 4) from FF cell block_ram.$procdff$486 ($dff).
Removed top 7 bits (of 8) from FF cell distributed_ram.$procdff$482 ($dff).
Removed top 7 bits (of 8) from FF cell distributed_ram_manual.$procdff$475 ($dff).
Removed top 7 bits (of 8) from FF cell distributed_ram_manual_syn.$procdff$473 ($dff).

8.8. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$memwr$\memory$attributes_test.v:16$425' in module `\block_ram': merged $dff to cell.
Checking cell `$memwr$\memory$attributes_test.v:38$432' in module `\distributed_ram': merged $dff to cell.
Checking cell `$memwr$\memory$attributes_test.v:60$439' in module `\distributed_ram_manual': merged $dff to cell.
Checking cell `$memwr$\memory$attributes_test.v:82$446' in module `\distributed_ram_manual_syn': merged $dff to cell.

8.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Finding unused cells or wires in module \distributed_ram..
Finding unused cells or wires in module \distributed_ram_manual..
Finding unused cells or wires in module \distributed_ram_manual_syn..
Removed 12 unused cells and 12 unused wires.
<suppressed ~16 debug messages>

8.10. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\block_ram':
  $memwr$\memory$attributes_test.v:16$425 ($memwr)
  $memrd$\memory$attributes_test.v:17$424 ($memrd)
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\distributed_ram':
  $memwr$\memory$attributes_test.v:38$432 ($memwr)
  $memrd$\memory$attributes_test.v:39$431 ($memrd)
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\distributed_ram_manual':
  $memwr$\memory$attributes_test.v:60$439 ($memwr)
  $memrd$\memory$attributes_test.v:61$438 ($memrd)
Collecting $memrd, $memwr and $meminit for memory `\memory' in module `\distributed_ram_manual_syn':
  $memwr$\memory$attributes_test.v:82$446 ($memwr)
  $memrd$\memory$attributes_test.v:83$445 ($memrd)

8.11. Executing OPT pass (performing simple optimizations).

8.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.
Optimizing module distributed_ram.
Optimizing module distributed_ram_manual.
Optimizing module distributed_ram_manual_syn.

8.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Finding identical cells in module `\distributed_ram'.
Finding identical cells in module `\distributed_ram_manual'.
Finding identical cells in module `\distributed_ram_manual_syn'.
Removed a total of 0 cells.

8.11.3. Executing OPT_RMDFF pass (remove dff with constant values).

8.11.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Finding unused cells or wires in module \distributed_ram..
Finding unused cells or wires in module \distributed_ram_manual..
Finding unused cells or wires in module \distributed_ram_manual_syn..

8.11.5. Finished fast OPT passes.

8.12. Printing statistics.

=== block_ram ===

   Number of wires:                 10
   Number of wire bits:             46
   Number of public wires:           6
   Number of public wire bits:      24
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  5
     $dff                            1
     $mem                            1
     $mux                            3

=== distributed_ram ===

   Number of wires:                 10
   Number of wire bits:             58
   Number of public wires:           6
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  5
     $dff                            1
     $mem                            1
     $mux                            3

=== distributed_ram_manual ===

   Number of wires:                 10
   Number of wire bits:             58
   Number of public wires:           6
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  5
     $dff                            1
     $mem                            1
     $mux                            3

=== distributed_ram_manual_syn ===

   Number of wires:                 10
   Number of wire bits:             58
   Number of public wires:           6
   Number of public wire bits:      30
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  5
     $dff                            1
     $mem                            1
     $mux                            3

8.13. Executing CHECK pass (checking for obvious problems).
checking module block_ram..
checking module distributed_ram..
checking module distributed_ram_manual..
checking module distributed_ram_manual_syn..
found and reported 0 problems.

9. Executing SYNTH_XILINX pass.

9.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\VCC'.
Generating RTLIL representation for module `\GND'.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\IBUFG'.
Generating RTLIL representation for module `\OBUF'.
Generating RTLIL representation for module `\IOBUF'.
Generating RTLIL representation for module `\OBUFT'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGCTRL'.
Generating RTLIL representation for module `\BUFHCE'.
Generating RTLIL representation for module `\INV'.
Generating RTLIL representation for module `\LUT1'.
Generating RTLIL representation for module `\LUT2'.
Generating RTLIL representation for module `\LUT3'.
Generating RTLIL representation for module `\LUT4'.
Generating RTLIL representation for module `\LUT5'.
Generating RTLIL representation for module `\LUT6'.
Generating RTLIL representation for module `\LUT6_2'.
Generating RTLIL representation for module `\MUXCY'.
Generating RTLIL representation for module `\MUXF7'.
Generating RTLIL representation for module `\MUXF8'.
Generating RTLIL representation for module `\XORCY'.
Generating RTLIL representation for module `\CARRY4'.
Generating RTLIL representation for module `\FDRE'.
Generating RTLIL representation for module `\FDSE'.
Generating RTLIL representation for module `\FDCE'.
Generating RTLIL representation for module `\FDPE'.
Generating RTLIL representation for module `\FDRE_1'.
Generating RTLIL representation for module `\FDSE_1'.
Generating RTLIL representation for module `\FDCE_1'.
Generating RTLIL representation for module `\FDPE_1'.
Generating RTLIL representation for module `\LDCE'.
Generating RTLIL representation for module `\LDPE'.
Generating RTLIL representation for module `\RAM16X1S'.
Generating RTLIL representation for module `\RAM16X1S_1'.
Generating RTLIL representation for module `\RAM32X1S'.
Generating RTLIL representation for module `\RAM32X1S_1'.
Generating RTLIL representation for module `\RAM64X1S'.
Generating RTLIL representation for module `\RAM64X1S_1'.
Generating RTLIL representation for module `\RAM128X1S'.
Generating RTLIL representation for module `\RAM128X1S_1'.
Generating RTLIL representation for module `\RAM256X1S'.
Generating RTLIL representation for module `\RAM512X1S'.
Generating RTLIL representation for module `\RAM16X2S'.
Generating RTLIL representation for module `\RAM32X2S'.
Generating RTLIL representation for module `\RAM64X2S'.
Generating RTLIL representation for module `\RAM16X4S'.
Generating RTLIL representation for module `\RAM32X4S'.
Generating RTLIL representation for module `\RAM16X8S'.
Generating RTLIL representation for module `\RAM32X8S'.
Generating RTLIL representation for module `\RAM16X1D'.
Generating RTLIL representation for module `\RAM16X1D_1'.
Generating RTLIL representation for module `\RAM32X1D'.
Generating RTLIL representation for module `\RAM32X1D_1'.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM64X1D_1'.
Generating RTLIL representation for module `\RAM128X1D'.
Generating RTLIL representation for module `\RAM256X1D'.
Generating RTLIL representation for module `\RAM32M'.
Generating RTLIL representation for module `\RAM32M16'.
Generating RTLIL representation for module `\RAM64M'.
Generating RTLIL representation for module `\RAM64M8'.
Generating RTLIL representation for module `\ROM16X1'.
Generating RTLIL representation for module `\ROM32X1'.
Generating RTLIL representation for module `\ROM64X1'.
Generating RTLIL representation for module `\ROM128X1'.
Generating RTLIL representation for module `\ROM256X1'.
Generating RTLIL representation for module `\SRL16E'.
Generating RTLIL representation for module `\SRLC16E'.
Generating RTLIL representation for module `\SRLC32E'.
Generating RTLIL representation for module `\MULT18X18'.
Generating RTLIL representation for module `\MULT18X18S'.
Generating RTLIL representation for module `\MULT18X18SIO'.
Generating RTLIL representation for module `\DSP48A'.
Generating RTLIL representation for module `\DSP48A1'.
Generating RTLIL representation for module `\DSP48E1'.
Successfully finished Verilog frontend.

9.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/cells_xtra.v' to AST representation.
Generating RTLIL representation for module `\FDCPE'.
Generating RTLIL representation for module `\FDRSE'.
Generating RTLIL representation for module `\LDCPE'.
Generating RTLIL representation for module `\AND2B1L'.
Generating RTLIL representation for module `\OR2L'.
Generating RTLIL representation for module `\MUXF5'.
Generating RTLIL representation for module `\MUXF6'.
Generating RTLIL representation for module `\MUXF9'.
Generating RTLIL representation for module `\CARRY8'.
Generating RTLIL representation for module `\ORCY'.
Generating RTLIL representation for module `\MULT_AND'.
Generating RTLIL representation for module `\SRL16'.
Generating RTLIL representation for module `\SRLC16'.
Generating RTLIL representation for module `\CFGLUT5'.
Generating RTLIL representation for module `\RAMB16_S1'.
Generating RTLIL representation for module `\RAMB16_S2'.
Generating RTLIL representation for module `\RAMB16_S4'.
Generating RTLIL representation for module `\RAMB16_S9'.
Generating RTLIL representation for module `\RAMB16_S18'.
Generating RTLIL representation for module `\RAMB16_S36'.
Generating RTLIL representation for module `\RAMB16_S1_S1'.
Generating RTLIL representation for module `\RAMB16_S1_S2'.
Generating RTLIL representation for module `\RAMB16_S1_S4'.
Generating RTLIL representation for module `\RAMB16_S1_S9'.
Generating RTLIL representation for module `\RAMB16_S1_S18'.
Generating RTLIL representation for module `\RAMB16_S1_S36'.
Generating RTLIL representation for module `\RAMB16_S2_S2'.
Generating RTLIL representation for module `\RAMB16_S2_S4'.
Generating RTLIL representation for module `\RAMB16_S2_S9'.
Generating RTLIL representation for module `\RAMB16_S2_S18'.
Generating RTLIL representation for module `\RAMB16_S2_S36'.
Generating RTLIL representation for module `\RAMB16_S4_S4'.
Generating RTLIL representation for module `\RAMB16_S4_S9'.
Generating RTLIL representation for module `\RAMB16_S4_S18'.
Generating RTLIL representation for module `\RAMB16_S4_S36'.
Generating RTLIL representation for module `\RAMB16_S9_S9'.
Generating RTLIL representation for module `\RAMB16_S9_S18'.
Generating RTLIL representation for module `\RAMB16_S9_S36'.
Generating RTLIL representation for module `\RAMB16_S18_S18'.
Generating RTLIL representation for module `\RAMB16_S18_S36'.
Generating RTLIL representation for module `\RAMB16_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S18_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S9'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S18'.
Generating RTLIL representation for module `\RAMB16BWE_S36_S36'.
Generating RTLIL representation for module `\RAMB16BWER'.
Generating RTLIL representation for module `\RAMB8BWER'.
Generating RTLIL representation for module `\FIFO16'.
Generating RTLIL representation for module `\RAMB16'.
Generating RTLIL representation for module `\RAMB32_S64_ECC'.
Generating RTLIL representation for module `\FIFO18'.
Generating RTLIL representation for module `\FIFO18_36'.
Generating RTLIL representation for module `\FIFO36'.
Generating RTLIL representation for module `\FIFO36_72'.
Generating RTLIL representation for module `\RAMB18'.
Generating RTLIL representation for module `\RAMB36'.
Generating RTLIL representation for module `\RAMB18SDP'.
Generating RTLIL representation for module `\RAMB36SDP'.
Generating RTLIL representation for module `\FIFO18E1'.
Generating RTLIL representation for module `\FIFO36E1'.
Generating RTLIL representation for module `\RAMB18E1'.
Generating RTLIL representation for module `\RAMB36E1'.
Generating RTLIL representation for module `\FIFO18E2'.
Generating RTLIL representation for module `\FIFO36E2'.
Generating RTLIL representation for module `\RAMB18E2'.
Generating RTLIL representation for module `\RAMB36E2'.
Generating RTLIL representation for module `\URAM288'.
Generating RTLIL representation for module `\URAM288_BASE'.
Generating RTLIL representation for module `\DSP48'.
Generating RTLIL representation for module `\DSP48E'.
Generating RTLIL representation for module `\DSP48E2'.
Generating RTLIL representation for module `\IFDDRCPE'.
Generating RTLIL representation for module `\IFDDRRSE'.
Generating RTLIL representation for module `\OFDDRCPE'.
Generating RTLIL representation for module `\OFDDRRSE'.
Generating RTLIL representation for module `\OFDDRTCPE'.
Generating RTLIL representation for module `\OFDDRTRSE'.
Generating RTLIL representation for module `\IDDR2'.
Generating RTLIL representation for module `\ODDR2'.
Generating RTLIL representation for module `\IDDR'.
Generating RTLIL representation for module `\IDDR_2CLK'.
Generating RTLIL representation for module `\ODDR'.
Generating RTLIL representation for module `\IDELAYCTRL'.
Generating RTLIL representation for module `\IDELAY'.
Generating RTLIL representation for module `\ISERDES'.
Generating RTLIL representation for module `\OSERDES'.
Generating RTLIL representation for module `\IODELAY'.
Generating RTLIL representation for module `\ISERDES_NODELAY'.
Generating RTLIL representation for module `\IODELAYE1'.
Generating RTLIL representation for module `\ISERDESE1'.
Generating RTLIL representation for module `\OSERDESE1'.
Generating RTLIL representation for module `\IDELAYE2'.
Generating RTLIL representation for module `\ODELAYE2'.
Generating RTLIL representation for module `\ISERDESE2'.
Generating RTLIL representation for module `\OSERDESE2'.
Generating RTLIL representation for module `\PHASER_IN'.
Generating RTLIL representation for module `\PHASER_IN_PHY'.
Generating RTLIL representation for module `\PHASER_OUT'.
Generating RTLIL representation for module `\PHASER_OUT_PHY'.
Generating RTLIL representation for module `\PHASER_REF'.
Generating RTLIL representation for module `\PHY_CONTROL'.
Generating RTLIL representation for module `\IDDRE1'.
Generating RTLIL representation for module `\ODDRE1'.
Generating RTLIL representation for module `\IDELAYE3'.
Generating RTLIL representation for module `\ODELAYE3'.
Generating RTLIL representation for module `\ISERDESE3'.
Generating RTLIL representation for module `\OSERDESE3'.
Generating RTLIL representation for module `\BITSLICE_CONTROL'.
Generating RTLIL representation for module `\RIU_OR'.
Generating RTLIL representation for module `\RX_BITSLICE'.
Generating RTLIL representation for module `\RXTX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE'.
Generating RTLIL representation for module `\TX_BITSLICE_TRI'.
Generating RTLIL representation for module `\IODELAY2'.
Generating RTLIL representation for module `\IODRP2'.
Generating RTLIL representation for module `\IODRP2_MCB'.
Generating RTLIL representation for module `\ISERDES2'.
Generating RTLIL representation for module `\OSERDES2'.
Generating RTLIL representation for module `\IBUF_DLY_ADJ'.
Generating RTLIL representation for module `\IBUF_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUF_ANALOG'.
Generating RTLIL representation for module `\IBUFE3'.
Generating RTLIL representation for module `\IBUFDS'.
Generating RTLIL representation for module `\IBUFDS_DLY_ADJ'.
Generating RTLIL representation for module `\IBUFDS_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDSE3'.
Generating RTLIL representation for module `\IBUFDS_DPHY'.
Generating RTLIL representation for module `\IBUFGDS'.
Generating RTLIL representation for module `\IBUFGDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUF_DCIEN'.
Generating RTLIL representation for module `\IOBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFE3'.
Generating RTLIL representation for module `\IOBUFDS'.
Generating RTLIL representation for module `\IOBUFDS_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDSE3'.
Generating RTLIL representation for module `\OBUFDS'.
Generating RTLIL representation for module `\OBUFDS_DPHY'.
Generating RTLIL representation for module `\OBUFTDS'.
Generating RTLIL representation for module `\KEEPER'.
Generating RTLIL representation for module `\PULLDOWN'.
Generating RTLIL representation for module `\PULLUP'.
Generating RTLIL representation for module `\DCIRESET'.
Generating RTLIL representation for module `\HPIO_VREF'.
Generating RTLIL representation for module `\BUFGCE'.
Generating RTLIL representation for module `\BUFGCE_1'.
Generating RTLIL representation for module `\BUFGMUX'.
Generating RTLIL representation for module `\BUFGMUX_1'.
Generating RTLIL representation for module `\BUFGMUX_CTRL'.
Generating RTLIL representation for module `\BUFGMUX_VIRTEX4'.
Generating RTLIL representation for module `\BUFG_GT'.
Generating RTLIL representation for module `\BUFG_GT_SYNC'.
Generating RTLIL representation for module `\BUFG_PS'.
Generating RTLIL representation for module `\BUFGCE_DIV'.
Generating RTLIL representation for module `\BUFH'.
Generating RTLIL representation for module `\BUFIO2'.
Generating RTLIL representation for module `\BUFIO2_2CLK'.
Generating RTLIL representation for module `\BUFIO2FB'.
Generating RTLIL representation for module `\BUFPLL'.
Generating RTLIL representation for module `\BUFPLL_MCB'.
Generating RTLIL representation for module `\BUFIO'.
Generating RTLIL representation for module `\BUFIODQS'.
Generating RTLIL representation for module `\BUFR'.
Generating RTLIL representation for module `\BUFMR'.
Generating RTLIL representation for module `\BUFMRCE'.
Generating RTLIL representation for module `\DCM'.
Generating RTLIL representation for module `\DCM_SP'.
Generating RTLIL representation for module `\DCM_CLKGEN'.
Generating RTLIL representation for module `\DCM_ADV'.
Generating RTLIL representation for module `\DCM_BASE'.
Generating RTLIL representation for module `\DCM_PS'.
Generating RTLIL representation for module `\PMCD'.
Generating RTLIL representation for module `\PLL_ADV'.
Generating RTLIL representation for module `\PLL_BASE'.
Generating RTLIL representation for module `\MMCM_ADV'.
Generating RTLIL representation for module `\MMCM_BASE'.
Generating RTLIL representation for module `\MMCME2_ADV'.
Generating RTLIL representation for module `\MMCME2_BASE'.
Generating RTLIL representation for module `\PLLE2_ADV'.
Generating RTLIL representation for module `\PLLE2_BASE'.
Generating RTLIL representation for module `\MMCME3_ADV'.
Generating RTLIL representation for module `\MMCME3_BASE'.
Generating RTLIL representation for module `\PLLE3_ADV'.
Generating RTLIL representation for module `\PLLE3_BASE'.
Generating RTLIL representation for module `\MMCME4_ADV'.
Generating RTLIL representation for module `\MMCME4_BASE'.
Generating RTLIL representation for module `\PLLE4_ADV'.
Generating RTLIL representation for module `\PLLE4_BASE'.
Generating RTLIL representation for module `\BUFT'.
Generating RTLIL representation for module `\IN_FIFO'.
Generating RTLIL representation for module `\OUT_FIFO'.
Generating RTLIL representation for module `\HARD_SYNC'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3E'.
Generating RTLIL representation for module `\STARTUP_SPARTAN3A'.
Generating RTLIL representation for module `\STARTUP_SPARTAN6'.
Generating RTLIL representation for module `\STARTUP_VIRTEX4'.
Generating RTLIL representation for module `\STARTUP_VIRTEX5'.
Generating RTLIL representation for module `\STARTUP_VIRTEX6'.
Generating RTLIL representation for module `\STARTUPE2'.
Generating RTLIL representation for module `\STARTUPE3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3'.
Generating RTLIL representation for module `\CAPTURE_SPARTAN3A'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX4'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX5'.
Generating RTLIL representation for module `\CAPTURE_VIRTEX6'.
Generating RTLIL representation for module `\CAPTUREE2'.
Generating RTLIL representation for module `\ICAP_SPARTAN3A'.
Generating RTLIL representation for module `\ICAP_SPARTAN6'.
Generating RTLIL representation for module `\ICAP_VIRTEX4'.
Generating RTLIL representation for module `\ICAP_VIRTEX5'.
Generating RTLIL representation for module `\ICAP_VIRTEX6'.
Generating RTLIL representation for module `\ICAPE2'.
Generating RTLIL representation for module `\ICAPE3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3'.
Generating RTLIL representation for module `\BSCAN_SPARTAN3A'.
Generating RTLIL representation for module `\BSCAN_SPARTAN6'.
Generating RTLIL representation for module `\BSCAN_VIRTEX4'.
Generating RTLIL representation for module `\BSCAN_VIRTEX5'.
Generating RTLIL representation for module `\BSCAN_VIRTEX6'.
Generating RTLIL representation for module `\BSCANE2'.
Generating RTLIL representation for module `\DNA_PORT'.
Generating RTLIL representation for module `\DNA_PORTE2'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX4'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX5'.
Generating RTLIL representation for module `\FRAME_ECC_VIRTEX6'.
Generating RTLIL representation for module `\FRAME_ECCE2'.
Generating RTLIL representation for module `\FRAME_ECCE3'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX4'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX5'.
Generating RTLIL representation for module `\USR_ACCESS_VIRTEX6'.
Generating RTLIL representation for module `\USR_ACCESSE2'.
Generating RTLIL representation for module `\POST_CRC_INTERNAL'.
Generating RTLIL representation for module `\SUSPEND_SYNC'.
Generating RTLIL representation for module `\KEY_CLEAR'.
Generating RTLIL representation for module `\MASTER_JTAG'.
Generating RTLIL representation for module `\SPI_ACCESS'.
Generating RTLIL representation for module `\EFUSE_USR'.
Generating RTLIL representation for module `\SYSMON'.
Generating RTLIL representation for module `\XADC'.
Generating RTLIL representation for module `\SYSMONE1'.
Generating RTLIL representation for module `\SYSMONE4'.
Generating RTLIL representation for module `\GTPA1_DUAL'.
Generating RTLIL representation for module `\GT11_CUSTOM'.
Generating RTLIL representation for module `\GT11_DUAL'.
Generating RTLIL representation for module `\GT11CLK'.
Generating RTLIL representation for module `\GT11CLK_MGT'.
Generating RTLIL representation for module `\GTP_DUAL'.
Generating RTLIL representation for module `\GTX_DUAL'.
Generating RTLIL representation for module `\CRC32'.
Generating RTLIL representation for module `\CRC64'.
Generating RTLIL representation for module `\GTHE1_QUAD'.
Generating RTLIL representation for module `\GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTXE1'.
Generating RTLIL representation for module `\IBUFDS_GTHE1'.
Generating RTLIL representation for module `\GTHE2_CHANNEL'.
Generating RTLIL representation for module `\GTHE2_COMMON'.
Generating RTLIL representation for module `\GTPE2_CHANNEL'.
Generating RTLIL representation for module `\GTPE2_COMMON'.
Generating RTLIL representation for module `\GTXE2_CHANNEL'.
Generating RTLIL representation for module `\GTXE2_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE2'.
Generating RTLIL representation for module `\GTHE3_CHANNEL'.
Generating RTLIL representation for module `\GTHE3_COMMON'.
Generating RTLIL representation for module `\GTHE4_CHANNEL'.
Generating RTLIL representation for module `\GTHE4_COMMON'.
Generating RTLIL representation for module `\GTYE3_CHANNEL'.
Generating RTLIL representation for module `\GTYE3_COMMON'.
Generating RTLIL representation for module `\GTYE4_CHANNEL'.
Generating RTLIL representation for module `\GTYE4_COMMON'.
Generating RTLIL representation for module `\IBUFDS_GTE3'.
Generating RTLIL representation for module `\IBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE3'.
Generating RTLIL representation for module `\OBUFDS_GTE3_ADV'.
Generating RTLIL representation for module `\OBUFDS_GTE4'.
Generating RTLIL representation for module `\OBUFDS_GTE4_ADV'.
Generating RTLIL representation for module `\PCIE_A1'.
Generating RTLIL representation for module `\PCIE_EP'.
Generating RTLIL representation for module `\PCIE_2_0'.
Generating RTLIL representation for module `\PCIE_2_1'.
Generating RTLIL representation for module `\PCIE_3_0'.
Generating RTLIL representation for module `\PCIE_3_1'.
Generating RTLIL representation for module `\PCIE40E4'.
Generating RTLIL representation for module `\EMAC'.
Generating RTLIL representation for module `\TEMAC'.
Generating RTLIL representation for module `\TEMAC_SINGLE'.
Generating RTLIL representation for module `\CMAC'.
Generating RTLIL representation for module `\CMACE4'.
Generating RTLIL representation for module `\PPC405_ADV'.
Generating RTLIL representation for module `\PPC440'.
Generating RTLIL representation for module `\MCB'.
Generating RTLIL representation for module `\PS7'.
Generating RTLIL representation for module `\PS8'.
Generating RTLIL representation for module `\ILKN'.
Generating RTLIL representation for module `\ILKNE4'.
Successfully finished Verilog frontend.

9.3. Executing HIERARCHY pass (managing design hierarchy).

9.3.1. Analyzing design hierarchy..
Top module:  \block_ram

9.3.2. Analyzing design hierarchy..
Top module:  \block_ram
Removing unused module `\distributed_ram'.
Removing unused module `\distributed_ram_manual'.
Removing unused module `\distributed_ram_manual_syn'.
Removed 3 unused modules.

9.4. Executing PROC pass (convert processes to netlists).

9.4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

9.4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

9.4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

9.4.4. Executing PROC_INIT pass (extract init attributes).

9.4.5. Executing PROC_ARST pass (detect async resets in processes).

9.4.6. Executing PROC_MUX pass (convert decision trees to multiplexers).

9.4.7. Executing PROC_DLATCH pass (convert process syncs to latches).

9.4.8. Executing PROC_DFF pass (convert process syncs to FFs).

9.4.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

9.5. Executing TRIBUF pass.

9.6. Executing DEMINOUT pass (demote inout ports to input or output).

9.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

9.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

9.9. Executing CHECK pass (checking for obvious problems).
checking module block_ram..
found and reported 0 problems.

9.10. Executing OPT pass (performing simple optimizations).

9.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

9.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

9.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \block_ram..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~3 debug messages>

9.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \block_ram.
Performed a total of 0 changes.

9.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\block_ram'.
Removed a total of 0 cells.

9.10.6. Executing OPT_RMDFF pass (remove dff with constant values).

9.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..

9.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module block_ram.

9.10.9. Finished OPT passes. (There is nothing left to do.)

9.11. Executing WREDUCE pass (reducing word size of cells).
Removed cell block_ram.$procmux$469 ($mux).
Removed cell block_ram.$procmux$467 ($mux).

9.12. Executing PEEPOPT pass (run peephole optimizers).

9.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \block_ram..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

9.14. Executing PMUX2SHIFTX pass.

9.15. Executing TECHMAP pass (map to technology primitives).

9.15.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

9.15.2. Continuing TECHMAP pass.
No more expansions possible.

9.16. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

9.17. Executing TECHMAP pass (map to technology primitives).

9.17.1. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/mul2dsp.v' to AST representation.
Generating RTLIL representation for module `\_80_mul'.
Generating RTLIL representation for module `\_90_soft_mul'.
Successfully finished Verilog frontend.

9.17.2. Executing Verilog-2005 frontend: /opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v
Parsing Verilog input from `/opt/eda/fpga/FOSS/memattr/yosys_release/share/xilinx/xc7_dsp_map.v' to AST representation.
Generating RTLIL representation for module `\$__MUL25X18'.
Successfully finished Verilog frontend.

9.17.3. Continuing TECHMAP pass.
No more expansions possible.

9.18. Executing OPT_EXPR pass (perform const folding).

9.19. Executing WREDUCE pass (reducing word size of cells).

9.20. Executing XILINX_DSP pass (pack resources into DSPs).

9.21. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module block_ram:
  created 0 $alu and 0 $macc cells.

9.22. Executing SHARE pass (SAT-based resource sharing).
