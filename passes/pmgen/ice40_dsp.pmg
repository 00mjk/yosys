pattern ice40_dsp

state <SigBit> clock
state <bool> clock_pol sigO_signed
state <SigSpec> sigA sigB sigH sigO
state <Cell*> addAB muxAB

match mul
	select mul->type.in($mul, $__MUL16X16)
	select GetSize(mul->getPort(\A)) + GetSize(mul->getPort(\B)) > 10
	select GetSize(mul->getPort(\Y)) > 10
endmatch

match ffA
	select ffA->type.in($dff)
	filter !port(mul, \A).remove_const().empty()
	filter includes(port(ffA, \Q).to_sigbit_set(), port(mul, \A).remove_const().to_sigbit_set())
	optional
endmatch

code sigA clock clock_pol
	sigA = port(mul, \A);

	if (ffA) {
		clock = port(ffA, \CLK).as_bit();
		clock_pol = param(ffA, \CLK_POLARITY).as_bool();

		sigA.replace(port(ffA, \Q), port(ffA, \D));
	}
endcode

match ffB
	select ffB->type.in($dff)
	filter !port(mul, \B).remove_const().empty()
	filter includes(port(ffB, \Q).to_sigbit_set(), port(mul, \B).remove_const().to_sigbit_set())
	optional
endmatch

code sigB clock clock_pol
	sigB = port(mul, \B);

	if (ffB) {
		SigBit c = port(ffB, \CLK).as_bit();
		bool cp = param(ffB, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;

		sigB.replace(port(ffB, \Q), port(ffB, \D));
	}
endcode

match ffH
	select ffH->type.in($dff)
	select nusers(port(ffH, \D)) == 2
	index <SigSpec> port(ffH, \D) === port(mul, \Y)
	optional
endmatch

code sigH clock clock_pol
	sigH = port(mul, \Y);

	if (ffH) {
		sigH = port(ffH, \Q);

		SigBit c = port(ffH, \CLK).as_bit();
		bool cp = param(ffH, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;
	}
endcode

match addA
	select addA->type.in($add)
	select nusers(port(addA, \A)) == 2
	index <SigSpec> port(addA, \A) === sigH
	optional
endmatch

match addB
	if !addA
	select addB->type.in($add, $sub)
	select nusers(port(addB, \B)) == 2
	index <SigSpec> port(addB, \B) === sigH
	optional
endmatch

code addAB sigO sigO_signed
	if (addA) {
		addAB = addA;
		sigO = port(addAB, \B);
		sigO_signed = param(addAB, \B_SIGNED).as_bool();
	}
	if (addB) {
		addAB = addB;
		sigO = port(addAB, \A);
		sigO_signed = param(addAB, \A_SIGNED).as_bool();
	}
	if (addAB) {
		int natural_mul_width = GetSize(sigA) + GetSize(sigB);
		int actual_mul_width = GetSize(sigH);
		int actual_acc_width = GetSize(sigO);

		if ((actual_acc_width > actual_mul_width) && (natural_mul_width > actual_mul_width))
			reject;
		if ((actual_acc_width != actual_mul_width) && (param(mul, \A_SIGNED).as_bool() != param(addAB, \A_SIGNED).as_bool()))
			reject;
	}
endcode

match muxA
	if addAB
	select muxA->type.in($mux)
	select nusers(port(muxA, \A)) == 2
	index <SigSpec> port(muxA, \A) === port(addAB, \Y)
	optional
endmatch

match muxB
	if addAB
	if !muxA
	select muxB->type.in($mux)
	select nusers(port(muxB, \B)) == 2
	index <SigSpec> port(muxB, \B) === port(addAB, \Y)
	optional
endmatch

code muxAB
	muxAB = addAB;
	if (muxA)
		muxAB = muxA;
	if (muxB)
		muxAB = muxB;
endcode

match ffO
	if muxAB
	select ffO->type.in($dff)
	filter nusers(port(muxAB, \Y)) == 2
	filter includes(port(ffO, \D).to_sigbit_set(), port(muxAB, \Y).to_sigbit_set())
	optional
endmatch

code clock clock_pol sigO
	if (ffO) {
		SigBit c = port(ffO, \CLK).as_bit();
		bool cp = param(ffO, \CLK_POLARITY).as_bool();

		if (port(ffO, \Q) != sigO) {
			sigO = port(muxAB, \Y);
			sigO.replace(port(ffO, \D), port(ffO, \Q));
		}

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;
	}
endcode
