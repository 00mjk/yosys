pattern ice40_dsp

state <SigBit> clock
state <bool> clock_pol sigO_signed
state <SigSpec> sigA sigB sigH sigO
state <Cell*> addAB muxAB

match mul
	select mul->type.in($mul, $__MUL16X16)
	select GetSize(mul->getPort(\A)) + GetSize(mul->getPort(\B)) > 10
	select GetSize(mul->getPort(\Y)) > 10
endmatch

match ffA
	select ffA->type.in($dff)
	filter !port(mul, \A).remove_const().empty()
	filter includes(port(ffA, \Q).to_sigbit_set(), port(mul, \A).remove_const().to_sigbit_set())
	optional
endmatch

code sigA clock clock_pol
	sigA = port(mul, \A);

	if (ffA) {
		clock = port(ffA, \CLK).as_bit();
		clock_pol = param(ffA, \CLK_POLARITY).as_bool();

		sigA.replace(port(ffA, \Q), port(ffA, \D));
	}
endcode

match ffB
	select ffB->type.in($dff)
	filter !port(mul, \B).remove_const().empty()
	filter includes(port(ffB, \Q).to_sigbit_set(), port(mul, \B).remove_const().to_sigbit_set())
	optional
endmatch

code sigB clock clock_pol
	sigB = port(mul, \B);

	if (ffB) {
		SigBit c = port(ffB, \CLK).as_bit();
		bool cp = param(ffB, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;

		sigB.replace(port(ffB, \Q), port(ffB, \D));
	}
endcode

match ffH
	select ffH->type.in($dff)
	select nusers(port(ffH, \D)) == 2
	index <SigSpec> port(ffH, \D) === port(mul, \Y)
	optional
endmatch

code sigH sigO clock clock_pol
	sigH = port(mul, \Y);
	sigO = sigH;

	if (ffH) {
		sigH = port(ffH, \Q);
		sigO = sigH;

		SigBit c = port(ffH, \CLK).as_bit();
		bool cp = param(ffH, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;
	}
endcode

match addA
	select addA->type.in($add)
	select nusers(port(addA, \A)) == 2
	index <SigSpec> port(addA, \A) === sigH
	optional
endmatch

match addB
	if !addA
	select addB->type.in($add, $sub)
	select nusers(port(addB, \B)) == 2
	index <SigSpec> port(addB, \B) === sigH
	optional
endmatch

code addAB sigO sigO_signed
	if (addA) {
		addAB = addA;
		sigO_signed = param(addAB, \B_SIGNED).as_bool();
	}
	if (addB) {
		addAB = addB;
		sigO_signed = param(addAB, \A_SIGNED).as_bool();
	}
	if (addAB) {
		int natural_mul_width = GetSize(sigA) + GetSize(sigB);
		int actual_mul_width = GetSize(sigH);
		int actual_acc_width = GetSize(sigO);

		if ((actual_acc_width > actual_mul_width) && (natural_mul_width > actual_mul_width))
			reject;
		if ((actual_acc_width != actual_mul_width) && (param(mul, \A_SIGNED).as_bool() != param(addAB, \A_SIGNED).as_bool()))
			reject;

		sigO = port(addAB, \Y);
	}
endcode

match muxA
	if addAB
	select muxA->type.in($mux)
	select nusers(port(muxA, \A)) == 2
	index <SigSpec> port(muxA, \A) === port(addAB, \Y)
	optional
endmatch

match muxB
	if addAB
	if !muxA
	select muxB->type.in($mux)
	select nusers(port(muxB, \B)) == 2
	index <SigSpec> port(muxB, \B) === port(addAB, \Y)
	optional
endmatch

code muxAB sigO
	muxAB = addAB;
	if (muxA)
		muxAB = muxA;
	if (muxB)
		muxAB = muxB;
	if (muxA || muxB)
		sigO = port(muxAB, \Y);
endcode

match ffO_lo
	select ffO_lo->type.in($dff)
	filter nusers(sigO.extract(0,16)) == 2
	filter includes(port(ffO_lo, \D).to_sigbit_set(), sigO.extract(0,16).to_sigbit_set())
	optional
endmatch

match ffO_hi
	select ffO_hi->type.in($dff)
	filter nusers(sigO.extract(16,16)) == 2
	filter includes(port(ffO_hi, \D).to_sigbit_set(), sigO.extract(16,16).to_sigbit_set())
	optional
endmatch

code clock clock_pol sigO
	if (ffO_lo || ffO_hi) {
		if (ffO_lo) {
			SigBit c = port(ffO_lo, \CLK).as_bit();
			bool cp = param(ffO_lo, \CLK_POLARITY).as_bool();

			if (clock != SigBit() && (c != clock || cp != clock_pol))
				reject;

			clock = c;
			clock_pol = cp;

			if (port(ffO_lo, \Q) != sigO.extract(0,16))
				sigO.replace(port(ffO_lo, \D), port(ffO_lo, \Q));
		}

		if (ffO_hi) {
			SigBit c = port(ffO_hi, \CLK).as_bit();
			bool cp = param(ffO_hi, \CLK_POLARITY).as_bool();

			if (clock != SigBit() && (c != clock || cp != clock_pol))
				reject;

			clock = c;
			clock_pol = cp;

			if (port(ffO_hi, \Q) != sigO.extract(16,16))
				sigO.replace(port(ffO_hi, \D), port(ffO_hi, \Q));
		}
	}
endcode
