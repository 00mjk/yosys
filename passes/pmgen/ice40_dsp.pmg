pattern ice40_dsp

state <SigBit> clock
state <bool> clock_pol cd_signed
state <std::set<SigBit>> sigAset sigBset
state <SigSpec> sigA sigB sigCD sigH sigO sigOused
state <Cell*> addAB muxAB

match mul
	select mul->type.in($mul, \SB_MAC16)
	select GetSize(mul->getPort(\A)) + GetSize(mul->getPort(\B)) > 10
endmatch

code sigAset sigBset
	SigSpec A = port(mul, \A);
	A.remove_const();
	sigAset = A.to_sigbit_set();
	SigSpec B = port(mul, \B);
	B.remove_const();
	sigBset = B.to_sigbit_set();
endcode

code sigH
	SigSpec O;
	if (mul->type == $mul)
		O = mul->getPort(\Y);
	else if (mul->type == \SB_MAC16)
		O = mul->getPort(\O);
	else log_abort();
	if (GetSize(O) <= 10)
		reject;
	// Only care about those bits that are used
	int i;
	for (i = 0; i < GetSize(O); i++) {
		if (nusers(O[i]) <= 1)
			break;
		sigH.append(O[i]);
	}
	log_assert(nusers(O.extract_end(i)) <= 1);
endcode

match ffA
	if mul->type != \SB_MAC16 || !param(mul, \A_REG).as_bool()
	if !sigAset.empty()
	select ffA->type.in($dff)
	optional
endmatch

code sigA clock clock_pol
	sigA = port(mul, \A);

	if (ffA) {
		auto ffAset = port(ffA, \Q).to_sigbit_set();
		if (!std::includes(ffAset.begin(), ffAset.end(), sigAset.begin(), sigAset.end()))
			reject;

		for (auto b : port(ffA, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		clock = port(ffA, \CLK).as_bit();
		clock_pol = param(ffA, \CLK_POLARITY).as_bool();

		sigA.replace(port(ffA, \Q), port(ffA, \D));
	}
endcode

match ffB
	if mul->type != \SB_MAC16 || !param(mul, \B_REG).as_bool()
	if !sigBset.empty()
	select ffB->type.in($dff)
	optional
endmatch

code sigB clock clock_pol
	sigB = port(mul, \B);

	if (ffB) {
		auto ffBset = port(ffB, \Q).to_sigbit_set();
		if (!std::includes(ffBset.begin(), ffBset.end(), sigBset.begin(), sigBset.end()))
			reject;

		for (auto b : port(ffB, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffB, \CLK).as_bit();
		bool cp = param(ffB, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;

		sigB.replace(port(ffB, \Q), port(ffB, \D));
	}
endcode

match ffFJKG
	// Ensure pipeline register is not already used
	if mul->type != \SB_MAC16 || (!param(mul, \TOP_8x8_MULT_REG).as_bool() && !param(mul, \BOT_8x8_MULT_REG).as_bool() && !param(mul, \PIPELINE_16x16_MULT_REG1).as_bool() && !param(mul, \PIPELINE_16x16_MULT_REG2).as_bool())
	select ffFJKG->type.in($dff)
	select nusers(port(ffFJKG, \D)) == 2
	index <SigSpec> port(ffFJKG, \D) === sigH
	optional
endmatch

code sigH sigO clock clock_pol
	if (ffFJKG) {
		sigH = port(ffFJKG, \Q);
		for (auto b : sigH)
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffFJKG, \CLK).as_bit();
		bool cp = param(ffFJKG, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;
	}

	sigO = sigH;
endcode

match addA
	select addA->type.in($add)
	select nusers(port(addA, \A)) == 2
	filter param(addA, \A_WIDTH).as_int() <= GetSize(sigH)
	//index <SigSpec> port(addA, \A) === sigH.extract(0, param(addA, \A_WIDTH).as_int())
	filter port(addA, \A) ==  sigH.extract(0, param(addA, \A_WIDTH).as_int())
	optional
endmatch

match addB
	if !addA
	select addB->type.in($add, $sub)
	select nusers(port(addB, \B)) == 2
	filter param(addB, \B_WIDTH).as_int() <= GetSize(sigH)
	//index <SigSpec> port(addB, \B) === sigH.extract(0, param(addB, \B_WIDTH).as_int())
	filter port(addB, \B) ==  sigH.extract(0, param(addB, \B_WIDTH).as_int())
	optional
endmatch

code addAB sigCD sigO cd_signed
	if (addA) {
		addAB = addA;
		sigCD = port(addAB, \B);
		cd_signed = param(addAB, \B_SIGNED).as_bool();
	}
	else if (addB) {
		addAB = addB;
		sigCD = port(addAB, \A);
		cd_signed = param(addAB, \A_SIGNED).as_bool();
	}
	if (addAB) {
		if (mul->type == \SB_MAC16) {
			// Ensure that adder is not used
			if (param(mul, \TOPOUTPUT_SELECT).as_int() != 3 ||
					param(mul, \BOTOUTPUT_SELECT).as_int() != 3)
				reject;
		}

		int natural_mul_width = GetSize(sigA) + GetSize(sigB);
		int actual_mul_width = GetSize(sigH);
		int actual_acc_width = GetSize(sigCD);

		if ((actual_acc_width > actual_mul_width) && (natural_mul_width > actual_mul_width))
			reject;
		// If accumulator, check adder width and signedness
		if (sigCD == sigH && (actual_acc_width != actual_mul_width) && (param(mul, \A_SIGNED).as_bool() != param(addAB, \A_SIGNED).as_bool()))
			reject;

		sigO = port(addAB, \Y);
	}
endcode

match muxA
	select muxA->type.in($mux)
	index <int> nusers(port(muxA, \A)) === 2
	index <SigSpec> port(muxA, \A) === sigO
	optional
endmatch

match muxB
	if !muxA
	select muxB->type.in($mux)
	index <int> nusers(port(muxB, \B)) === 2
	index <SigSpec> port(muxB, \B) === sigO
	optional
endmatch

code muxAB sigO
	if (muxA)
		muxAB = muxA;
	else if (muxB)
		muxAB = muxB;
	if (muxAB)
		sigO = port(muxAB, \Y);
endcode

match ffO
	// Ensure that register is not already used
	if mul->type != \SB_MAC16 || (mul->parameters.at(\TOPOUTPUT_SELECT, 0).as_int() != 1 && mul->parameters.at(\BOTOUTPUT_SELECT, 0).as_int() != 1)
	// Ensure that OLOADTOP/OLOADBOT is unused or zero
	if mul->type != \SB_MAC16 || (mul->connections_.at(\OLOADTOP, State::S0).is_fully_zero() && mul->connections_.at(\OLOADBOT, State::S0).is_fully_zero())
	if nusers(sigO) == 2
	select ffO->type.in($dff)
	filter GetSize(port(ffO, \D)) >= GetSize(sigO)
	slice offset GetSize(port(ffO, \D))
	filter offset+GetSize(sigO) <= GetSize(port(ffO, \D)) && port(ffO, \D).extract(offset, GetSize(sigO)) == sigO
	optional
endmatch

match ffO_lo
	if !ffO && GetSize(sigO) > 16
	// Ensure that register is not already used
	if mul->type != \SB_MAC16 || (mul->parameters.at(\TOPOUTPUT_SELECT, 0).as_int() != 1 && mul->parameters.at(\BOTOUTPUT_SELECT, 0).as_int() != 1)
	// Ensure that OLOADTOP/OLOADBOT is unused or zero
	if mul->type != \SB_MAC16 || (mul->connections_.at(\OLOADTOP, State::S0).is_fully_zero() && mul->connections_.at(\OLOADBOT, State::S0).is_fully_zero())
	if nusers(sigO.extract(0, 16)) == 2
	select ffO_lo->type.in($dff)
	filter GetSize(port(ffO_lo, \D)) >= 16
	slice offset GetSize(port(ffO_lo, \D))
	filter offset+GetSize(sigO) <= GetSize(port(ffO_lo, \D)) && port(ffO_lo, \D).extract(offset, 16) == sigO.extract(0, 16)
	optional
endmatch

code clock clock_pol sigO sigCD cd_signed
	Cell* ff = nullptr;
	if (ffO)
		ff = ffO;
	else if (ffO_lo)
		ff = ffO_lo;
	if (ff) {
		for (auto b : port(ff, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ff, \CLK).as_bit();
		bool cp = param(ff, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;

		sigO.replace(port(ff, \D), port(ff, \Q));

		// Loading value into output register is not
		//   supported unless using accumulator
		if (muxAB) {
			if (sigCD != sigO)
				reject;
			if (muxA)
				sigCD = port(muxAB, \B);
			else if (muxB)
				sigCD = port(muxAB, \A);
			else log_abort();

			cd_signed = addAB && param(addAB, \A_SIGNED).as_bool() && param(addAB, \B_SIGNED).as_bool();
		}
	}
	sigCD.extend_u0(32, cd_signed);
endcode

code
	accept;
endcode
