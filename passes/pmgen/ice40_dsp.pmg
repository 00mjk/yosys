pattern ice40_dsp

state <SigBit> clock
state <bool> clock_pol
state <std::set<SigBit>> sigAset sigBset
state <SigSpec> sigA sigB sigCD sigH sigO sigOused
state <Cell*> addAB muxAB

match mul
	select mul->type.in($mul, \SB_MAC16)
	select GetSize(mul->getPort(\A)) + GetSize(mul->getPort(\B)) > 10
endmatch

code sigAset sigBset
	SigSpec A = port(mul, \A);
	A.remove_const();
	sigAset = A.to_sigbit_set();
	SigSpec B = port(mul, \B);
	B.remove_const();
	sigBset = B.to_sigbit_set();
endcode

code sigH
	if (mul->type == $mul)
		sigH = mul->getPort(\Y);
	else if (mul->type == \SB_MAC16)
		sigH = mul->getPort(\O);
	else log_abort();
	if (GetSize(sigH) <= 10)
		reject;
endcode

match ffA
	if mul->type != \SB_MAC16 || !param(mul, \A_REG).as_bool()
	if !sigAset.empty()
	select ffA->type.in($dff)
	filter includes(port(ffA, \Q).to_sigbit_set(), sigAset)
	optional
endmatch

code sigA clock clock_pol
	sigA = port(mul, \A);

	if (ffA) {
		for (auto b : port(ffA, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		clock = port(ffA, \CLK).as_bit();
		clock_pol = param(ffA, \CLK_POLARITY).as_bool();

		sigA.replace(port(ffA, \Q), port(ffA, \D));
	}
endcode

match ffB
	if mul->type != \SB_MAC16 || !param(mul, \B_REG).as_bool()
	if !sigBset.empty()
	select ffB->type.in($dff)
	filter includes(port(ffB, \Q).to_sigbit_set(), sigBset)
	optional
endmatch

code sigB clock clock_pol
	sigB = port(mul, \B);

	if (ffB) {
		for (auto b : port(ffB, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffB, \CLK).as_bit();
		bool cp = param(ffB, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;

		sigB.replace(port(ffB, \Q), port(ffB, \D));
	}
endcode

match ffH
	if mul->type != \SB_MAC16 || (!param(mul, \TOP_8x8_MULT_REG).as_bool() && !param(mul, \BOT_8x8_MULT_REG).as_bool() && !param(mul, \PIPELINE_16x16_MULT_REG1).as_bool() && !param(mul, \PIPELINE_16x16_MULT_REG2).as_bool())
	select ffH->type.in($dff)
	select nusers(port(ffH, \D)) == 2
	index <SigSpec> port(ffH, \D) === sigH
	// Ensure pipeline register is not already used
	optional
endmatch

code sigH sigO clock clock_pol
	sigO = sigH;

	if (ffH) {
		sigH = port(ffH, \Q);
		for (auto b : sigH)
			if (b.wire->get_bool_attribute(\keep))
				reject;

		sigO = sigH;

		SigBit c = port(ffH, \CLK).as_bit();
		bool cp = param(ffH, \CLK_POLARITY).as_bool();

		if (clock != SigBit() && (c != clock || cp != clock_pol))
			reject;

		clock = c;
		clock_pol = cp;
	}
endcode

match addA
	select addA->type.in($add)
	select nusers(port(addA, \A)) == 2
	filter param(addA, \A_WIDTH).as_int() <= GetSize(sigH)
	//index <SigSpec> port(addA, \A) === sigH.extract(0, param(addA, \A_WIDTH).as_int())
	filter port(addA, \A) ==  sigH.extract(0, param(addA, \A_WIDTH).as_int())
	optional
endmatch

match addB
	if !addA
	select addB->type.in($add, $sub)
	select nusers(port(addB, \B)) == 2
	filter param(addB, \B_WIDTH).as_int() <= GetSize(sigH)
	//index <SigSpec> port(addB, \B) === sigH.extract(0, param(addB, \B_WIDTH).as_int())
	filter port(addB, \B) ==  sigH.extract(0, param(addB, \B_WIDTH).as_int())
	optional
endmatch

code addAB sigCD sigO
	bool CD_SIGNED = false;
	if (addA) {
		addAB = addA;
		sigCD = port(addAB, \B);
		CD_SIGNED = param(addAB, \B_SIGNED).as_bool();
	}
	if (addB) {
		addAB = addB;
		sigCD = port(addAB, \A);
		CD_SIGNED = param(addAB, \A_SIGNED).as_bool();
	}
	if (addAB) {
		if (mul->type == \SB_MAC16) {
			// Ensure that adder is not used
			if (param(mul, \TOPOUTPUT_SELECT).as_int() != 3 ||
					param(mul, \BOTOUTPUT_SELECT).as_int() != 3)
				reject;
		}

		int natural_mul_width = GetSize(sigA) + GetSize(sigB);
		int actual_mul_width = GetSize(sigH);
		int actual_acc_width = GetSize(sigCD);

		if ((actual_acc_width > actual_mul_width) && (natural_mul_width > actual_mul_width))
			reject;
		// If accumulator, check adder width and signedness
		if (sigCD == sigH && (actual_acc_width != actual_mul_width) && (param(mul, \A_SIGNED).as_bool() != param(addAB, \A_SIGNED).as_bool()))
			reject;

		sigO = port(addAB, \Y);
		sigCD.extend_u0(32, CD_SIGNED);
	}
endcode

match muxA
	select muxA->type.in($mux)
	index <int> nusers(port(muxA, \A)) === 2
	index <SigSpec> port(muxA, \A) === sigO
	optional
endmatch

match muxB
	if !muxA
	select muxB->type.in($mux)
	index <int> nusers(port(muxB, \B)) === 2
	index <SigSpec> port(muxB, \B) === sigO
	optional
endmatch

code muxAB
	if (muxA)
		muxAB = muxA;
	else if (muxB)
		muxAB = muxB;
endcode

// Extract the bits of P that actually have a consumer
// (as opposed to being a dummy)
code sigOused
	for (int i = 0; i < GetSize(sigO); i++)
		if (!sigO[i].wire || nusers(sigO[i]) == 1)
			sigOused.append(State::Sx);
		else
			sigOused.append(sigO[i]);
endcode

match ffO_lo
	if nusers(sigOused.extract(0,std::min(16,GetSize(sigOused)))) == 2
	select ffO_lo->type.in($dff)
	optional
endmatch

code
	if (ffO_lo) {
		SigSpec O = sigOused.extract(0,std::min(16,param(ffO_lo, \WIDTH).as_int()));
		O.remove_const();
		if (!includes(port(ffO_lo, \D).to_sigbit_set(), O.to_sigbit_set()))
			reject;
	}
endcode

match ffO_hi
	if GetSize(sigOused) > 16
	if nusers(sigOused.extract_end(16)) == 2
	select ffO_hi->type.in($dff)
	optional
endmatch

code
	if (ffO_hi) {
		SigSpec O = sigOused.extract_end(16);
		O.remove_const();
		if (!includes(port(ffO_hi, \D).to_sigbit_set(), O.to_sigbit_set()))
			reject;
	}
endcode

code clock clock_pol sigO sigCD
	if (ffO_lo || ffO_hi) {
		if (mul->type == \SB_MAC16) {
			// Ensure that register is not already used
			if (param(mul, \TOPOUTPUT_SELECT).as_int() == 1 ||
					param(mul, \BOTOUTPUT_SELECT).as_int() == 1)
				reject;

			// Ensure that OLOADTOP/OLOADBOT is unused or zero
			if ((mul->hasPort(\OLOADTOP) && !port(mul, \OLOADTOP).is_fully_zero())
				|| (mul->hasPort(\OLOADBOT) && !port(mul, \OLOADBOT).is_fully_zero()))
				reject;
		}

		if (ffO_lo) {
			for (auto b : port(ffO_lo, \Q))
				if (b.wire->get_bool_attribute(\keep))
					reject;

			SigBit c = port(ffO_lo, \CLK).as_bit();
			bool cp = param(ffO_lo, \CLK_POLARITY).as_bool();

			if (clock != SigBit() && (c != clock || cp != clock_pol))
				reject;

			clock = c;
			clock_pol = cp;

			sigO.replace(port(ffO_lo, \D), port(ffO_lo, \Q));
		}

		if (ffO_hi) {
			for (auto b : port(ffO_hi, \Q))
				if (b.wire->get_bool_attribute(\keep))
					reject;

			SigBit c = port(ffO_hi, \CLK).as_bit();
			bool cp = param(ffO_hi, \CLK_POLARITY).as_bool();

			if (clock != SigBit() && (c != clock || cp != clock_pol))
				reject;

			clock = c;
			clock_pol = cp;

			sigO.replace(port(ffO_hi, \D), port(ffO_hi, \Q));
		}

		// Loading value into output register is not
		//   supported unless using accumulator
		if (muxAB) {
			if (sigCD != sigO)
				reject;
			if (muxA)
				sigCD = port(muxAB, \B);
			else if (muxB)
				sigCD = port(muxAB, \A);
			else log_abort();
			sigCD.extend_u0(32, addAB && param(addAB, \A_SIGNED).as_bool() && param(addAB, \B_SIGNED).as_bool());
		}
	}
endcode
