pattern xilinx_dsp

state <SigBit> clock
state <SigSpec> sigA sigffAmux sigB sigffBmux sigC sigM sigP
state <IdString> ffAmuxAB ffBmuxAB ffMmuxAB ffPmuxAB postAddAB postAddMuxAB

match dsp
	select dsp->type.in(\DSP48E1)
endmatch

code sigA sigffAmux sigB sigffBmux sigM
	sigA = port(dsp, \A);
	int i;
	for (i = GetSize(sigA)-1; i > 0; i--)
		if (sigA[i] != sigA[i-1])
			break;
	// Do not remove non-const sign bit
	if (sigA[i].wire)
		++i;
	sigA.remove(i, GetSize(sigA)-i);
	sigB = port(dsp, \B);
	for (i = GetSize(sigB)-1; i > 0; i--)
		if (sigB[i] != sigB[i-1])
			break;
	// Do not remove non-const sign bit
	if (sigB[i].wire)
		++i;
	sigB.remove(i, GetSize(sigB)-i);

	SigSpec P = port(dsp, \P);
	// Only care about those bits that are used
	for (i = 0; i < GetSize(P); i++) {
		if (nusers(P[i]) <= 1)
			break;
		sigM.append(P[i]);
	}
	log_assert(nusers(P.extract_end(i)) <= 1);
	//if (GetSize(sigM) <= 10)
	//	reject;
endcode

match ffA
	if param(dsp, \AREG).as_int() == 0
	select ffA->type.in($dff)
	// DSP48E1 does not support clock inversion
	select param(ffA, \CLK_POLARITY).as_bool()
	filter GetSize(port(ffA, \Q)) >= GetSize(sigA)
	slice offset GetSize(port(ffA, \Q))
	filter offset+GetSize(sigA) <= GetSize(port(ffA, \Q)) && port(ffA, \Q).extract(offset, GetSize(sigA)) == sigA
	optional
endmatch

code sigA sigffAmux clock
	if (ffA) {
		for (auto b : port(ffA, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		clock = port(ffA, \CLK).as_bit();

		sigffAmux = sigA;
		sigA.replace(port(ffA, \Q), port(ffA, \D));
	}
endcode

match ffAmux
	if ffA
	select ffAmux->type.in($mux)
	choice <IdString> AB {\A, \B}
	index <SigSpec> port(ffAmux, \Y) === sigA
	index <SigSpec> port(ffAmux, AB) === sigffAmux
	set ffAmuxAB AB
	semioptional
endmatch

match ffB
	if param(dsp, \BREG).as_int() == 0
	select ffB->type.in($dff)
	// DSP48E1 does not support clock inversion
	select param(ffB, \CLK_POLARITY).as_bool()
	filter GetSize(port(ffB, \Q)) >= GetSize(sigB)
	slice offset GetSize(port(ffB, \Q))
	filter offset+GetSize(sigB) <= GetSize(port(ffB, \Q)) && port(ffB, \Q).extract(offset, GetSize(sigB)) == sigB
	optional
endmatch

code sigB sigffBmux clock
	if (ffB) {
		for (auto b : port(ffB, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffB, \CLK).as_bit();

		if (clock != SigBit() && c != clock)
			reject;

		clock = c;

		sigffBmux = sigB;
		sigB.replace(port(ffB, \Q), port(ffB, \D));
	}
endcode

match ffBmux
	if ffB
	select ffBmux->type.in($mux)
	choice <IdString> AB {\A, \B}
	index <SigSpec> port(ffBmux, \Y) === sigB
	index <SigSpec> port(ffBmux, AB) === sigffBmux
	set ffBmuxAB AB
	semioptional
endmatch

match ffMmux
	select ffMmux->type.in($mux)
	select nusers(port(ffMmux, \Y)) == 2
	filter GetSize(port(ffMmux, \Y)) <= GetSize(sigM)
	choice <IdString> AB {\A, \B}
	filter port(ffMmux, AB) == sigM.extract(0, GetSize(port(ffMmux, \Y)))
	filter nusers(sigM.extract_end(GetSize(port(ffMmux, AB)))) <= 1
	set ffMmuxAB AB
	optional
endmatch

code sigM
	if (ffMmux)
		sigM = port(ffMmux, \Y);
endcode

match ffM
	if param(dsp, \MREG).as_int() == 0
	select ffM->type.in($dff)
	// DSP48E1 does not support clock inversion
	select param(ffM, \CLK_POLARITY).as_bool()
	select nusers(port(ffM, \D)) == 2
	filter GetSize(port(ffM, \D)) <= GetSize(sigM)
	filter port(ffM, \D) == sigM.extract(0, GetSize(port(ffM, \D)))
	filter nusers(sigM.extract_end(GetSize(port(ffM, \D)))) <= 1
	// Check ffMmux (when present) is a $dff enable mux
	filter !ffMmux || port(ffM, \Q) == port(ffMmux, ffMmuxAB == \A ? \B : \A)
	optional
endmatch

code clock sigM sigP
	if (ffM) {
		sigM = port(ffM, \Q);

		for (auto b : sigM)
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffM, \CLK).as_bit();

		if (clock != SigBit() && c != clock)
			reject;

		clock = c;
	}
	// Cannot have ffMmux enable mux without ffM
	else if (ffMmux)
		reject;

	sigP = sigM;
endcode

match postAdd
	// Ensure that Z mux is not already used
	if port(dsp, \OPMODE).extract(4,3).is_fully_zero()

	select postAdd->type.in($add)
	select param(postAdd, \A_SIGNED).as_bool() && param(postAdd, \B_SIGNED).as_bool()
	choice <IdString> AB {\A, \B}
	select nusers(port(postAdd, AB)) <= 3
	filter ffMmux || nusers(port(postAdd, AB)) == 2
	filter !ffMmux || nusers(port(postAdd, AB)) == 3
	filter GetSize(port(postAdd, AB)) <= GetSize(sigP)
	filter port(postAdd, AB) == sigP.extract(0, GetSize(port(postAdd, AB)))
	filter nusers(sigP.extract_end(GetSize(port(postAdd, AB)))) <= 1
	set postAddAB AB
	optional
endmatch

code sigC sigP
	if (postAdd) {
		sigC = port(postAdd, postAddAB == \A ? \B : \A);

		// TODO for DSP48E1, which will have sign extended inputs/outputs
		//int natural_mul_width = GetSize(port(dsp, \A)) + GetSize(port(dsp, \B));
		//int actual_mul_width = GetSize(sigP);
		//int actual_acc_width = GetSize(sigC);

		//if ((actual_acc_width > actual_mul_width) && (natural_mul_width > actual_mul_width))
		//	reject;
		//if ((actual_acc_width != actual_mul_width) && (param(dsp, \A_SIGNED).as_bool() != param(postAdd, \A_SIGNED).as_bool()))
		//	reject;

		sigP = port(postAdd, \Y);
	}
endcode

match ffPmux
	select ffPmux->type.in($mux)
	select nusers(port(ffPmux, \Y)) == 2
	filter GetSize(port(ffPmux, \Y)) <= GetSize(sigP)
	choice <IdString> AB {\A, \B}
	filter port(ffPmux, AB) == sigP.extract(0, GetSize(port(ffPmux, \Y)))
	filter nusers(sigP.extract_end(GetSize(port(ffPmux, AB)))) <= 1
	set ffPmuxAB AB
	optional
endmatch

code sigP
	if (ffPmux)
		sigP.replace(port(ffPmux, ffPmuxAB), port(ffPmux, \Y));
endcode

match ffP
	if param(dsp, \PREG).as_int() == 0
	select ffP->type.in($dff)
	// DSP48E1 does not support clock inversion
	select param(ffP, \CLK_POLARITY).as_bool()
	filter GetSize(port(ffP, \D)) >= GetSize(sigP)
	slice offset GetSize(port(ffP, \D))
	filter offset+GetSize(sigP) <= GetSize(port(ffP, \D)) && port(ffP, \D).extract(offset, GetSize(sigP)) == sigP
	// Check ffPmux (when present) is a $dff enable mux
	filter !ffPmux || port(ffP, \Q) == port(ffPmux, ffPmuxAB == \A ? \B : \A)
	optional
endmatch

code ffP sigP clock
	if (ffP) {
		for (auto b : port(ffP, \Q))
			if (b.wire->get_bool_attribute(\keep))
				reject;

		SigBit c = port(ffP, \CLK).as_bit();

		if (clock != SigBit() && c != clock)
			reject;

		clock = c;

		sigP.replace(port(ffP, \D), port(ffP, \Q));
	}
	// Cannot have ffPmux enable mux without ffP
	else if (ffPmux)
		reject;
endcode

match postAddMux
	if postAdd
	if ffP
	select postAddMux->type.in($mux)
	select nusers(port(postAddMux, \Y)) == 2
	choice <IdString> AB {\A, \B}
	index <SigSpec> port(postAddMux, AB) === sigP
	index <SigSpec> port(postAddMux, \Y) === sigC
	set postAddMuxAB AB
	optional
endmatch

code sigC
	if (postAddMux)
		sigC = port(postAddMux, postAddMuxAB == \A ? \B : \A);
endcode

code
	accept;
endcode
